#!/usr/bin/perl
#*****************************************************************************
#
#  Copyright (c) 2002 Guillaume Cottenceau
#  Copyright (c) 2002-2007 Thierry Vignaud <tvignaud@mandriva.com>
#  Copyright (c) 2003, 2004, 2005 MandrakeSoft SA
#  Copyright (c) 2005-2007 Mandriva SA
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2, as
#  published by the Free Software Foundation.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
#
#*****************************************************************************
#
# $Id$

use strict;
use MDK::Common::Func 'any';
use lib qw(/usr/lib/libDrakX);
use common;
use POSIX qw(_exit);
use URPM;
use utf8;
use standalone;

use Rpmdrake::init;
use rpmdrake;
use Rpmdrake::rpmnew;
use Rpmdrake::formatting;
use Rpmdrake::pkg;
use urpm::media;
use urpm::select;

use mygtk2 qw(gtknew);  #- do not import anything else, especially gtkadd() which conflicts with ugtk2 one
use ugtk2 qw(:all);
use Gtk2::Gdk::Keysyms;

$ugtk2::wm_icon = "title-$MODE";

our $w;
my $treeview_dialog_run = 0;
our $statusbar;

sub interactive_list_ { interactive_list(@_, if_($::main_window, transient => $::main_window)) }
sub wait_msg_with_banner { push @_, banner => 1 if $::isEmbedded && !$treeview_dialog_run; &statusbar_msg }
sub interactive_msg_with_banner { push @_, banner => 1 if $::isEmbedded; &interactive_msg }

warn_about_user_mode();

my $dont_show_selections = $> ? 1 : 0;

#- /usr/share/rpmlint/config (duplicates are normal, so that we are not too far away from .py)
my %group_icons = (
	N("Accessibility") => 'accessibility_section',
	N("Archiving") => 'archiving_section',
	join('|', N("Archiving"), N("Backup")) => 'backup_section',
	join('|', N("Archiving"), N("Cd burning")) => 'cd_burning_section',
	join('|', N("Archiving"), N("Compression")) => 'compression_section',
	join('|', N("Archiving"), N("Other")) => 'other_archiving',
	N("Books") => 'documentation_section',
	join('|', N("Books"), N("Computer books")) => 'documentation_section',
	join('|', N("Books"), N("Faqs")) => 'documentation_section',
	join('|', N("Books"), N("Howtos")) => 'documentation_section',
	join('|', N("Books"), N("Literature")) => 'documentation_section',
	join('|', N("Books"), N("Other")) => 'education_other_section',
     N("Cluster") => 'parallel_computing_section',
	join('|', N("Cluster"), N("Message Passing")) => '',
	join('|', N("Cluster"), N("Queueing Services")) => '',
	N("Communications") => 'communications_section',
	N("Databases") => 'databases_section',
	N("Development") => 'development_section',
	join('|', N("Development"), N("C")) => '',
	join('|', N("Development"), N("C++")) => '',
	join('|', N("Development"), N("Databases")) => 'databases_section',
	join('|', N("Development"), N("GNOME and GTK+")) => 'gnome_section',
	join('|', N("Development"), N("Java")) => '',
	join('|', N("Development"), N("KDE and Qt")) => 'kde_section',
	join('|', N("Development"), N("Kernel")) => 'hardware_configuration_section',
	join('|', N("Development"), N("Other")) => 'development_tools_section',
	join('|', N("Development"), N("Perl")) => '',
	join('|', N("Development"), N("PHP")) => '',
	join('|', N("Development"), N("Python")) => '',
	N("Editors") => 'emulators_section',
	N("Education") => 'education_section',
	N("Emulators") => 'emulators_section',
	N("File tools") => 'file_tools_section',
	N("Games") => 'amusement_section',
	join('|', N("Games"), N("Adventure")) => 'adventure_section',
	join('|', N("Games"), N("Arcade")) => 'arcade_section',
	join('|', N("Games"), N("Boards")) => 'boards_section',
	join('|', N("Games"), N("Cards")) => 'cards_section',
	join('|', N("Games"), N("Other")) => 'other_amusement',
	join('|', N("Games"), N("Puzzles")) => 'puzzle_section',
	join('|', N("Games"), N("Sports")) => 'sport_section',
	join('|', N("Games"), N("Strategy")) => 'strategy_section',
	N("Graphical desktop") => 'office_section',
	join('|', N("Graphical desktop"),
          #-PO: This is a package/product name. Only translate it if needed:
          N("Enlightenment")) => '',
	join('|', N("Graphical desktop"), N("FVWM based")) => '',
	join('|', N("Graphical desktop"),
          #-PO: This is a package/product name. Only translate it if needed:
          N("GNOME")) => 'gnome_section',
	join('|', N("Graphical desktop"),
          #-PO: This is a package/product name. Only translate it if needed:
          N("Icewm")) => '',
	join('|', N("Graphical desktop"),
          #-PO: This is a package/product name. Only translate it if needed:
          N("KDE")) => 'kde_section',
	join('|', N("Graphical desktop"), N("Other")) => 'more_applications_other_section',
	join('|', N("Graphical desktop"),
          #-PO: This is a package/product name. Only translate it if needed:
          N("Sawfish")) => '',
	join('|', N("Graphical desktop"),
          #-PO: This is a package/product name. Only translate it if needed:
          N("WindowMaker")) => '',
	join('|', N("Graphical desktop"),
          #-PO: This is a package/product name. Only translate it if needed:
          N("Xfce")) => '',
	N("Graphics") => 'graphics_section',
	N("Monitoring") => 'monitoring_section',
	N("Multimedia") => 'multimedia_section',
	join('|', N("Multimedia"), N("Video")) => 'video_section',
	N("Networking") => 'networking_section',
	join('|', N("Networking"), N("Chat")) => 'chat_section',
	join('|', N("Networking"), N("File transfer")) => 'file_transfer_section',
	join('|', N("Networking"), N("IRC")) => 'irc_section',
	join('|', N("Networking"), N("Instant messaging")) => 'instant_messaging_section',
	join('|', N("Networking"), N("Mail")) => 'mail_section',
	join('|', N("Networking"), N("News")) => 'news_section',
	join('|', N("Networking"), N("Other")) => 'other_networking',
	join('|', N("Networking"), N("Remote access")) => 'remote_access_section',
	join('|', N("Networking"), N("WWW")) => 'networking_www_section',
	N("Office") => 'office_section',
	N("Public Keys") => 'packaging_section',
	N("Publishing") => 'publishing_section',
	N("Sciences") => 'sciences_section',
	join('|', N("Sciences"), N("Astronomy")) => 'astronomy_section',
	join('|', N("Sciences"), N("Biology")) => 'biology_section',
	join('|', N("Sciences"), N("Chemistry")) => 'chemistry_section',
	join('|', N("Sciences"), N("Computer science")) => 'computer_science_section',
	join('|', N("Sciences"), N("Geosciences")) => 'geosciences_section',
	join('|', N("Sciences"), N("Mathematics")) => 'mathematics_section',
	join('|', N("Sciences"), N("Other")) => 'other_sciences',
	join('|', N("Sciences"), N("Physics")) => 'physics_section',
	N("Shells") => 'shells_section',
	N("Sound") => 'sound_section',
	N("System") => 'system_section',
	join('|', N("System"), N("Base")) => 'system_section',
	join('|', N("System"), N("Configuration")) => 'configuration_section',
	join('|', N("System"), N("Configuration"), N("Boot and Init")) => 'boot_init_section',
	join('|', N("System"), N("Configuration"), N("Hardware")) => 'hardware_configuration_section',
	join('|', N("System"), N("Configuration"), N("Networking")) => 'networking_configuration_section',
	join('|', N("System"), N("Configuration"), N("Other")) => 'system_other_section',
	join('|', N("System"), N("Configuration"), N("Packaging")) => 'packaging_section',
	join('|', N("System"), N("Configuration"), N("Printing")) => 'printing_section',
	join('|', N("System"), N("Deploiement")) => '',
	join('|', N("System"), N("Deployment")) => '',
	join('|', N("System"), N("Fonts")) => 'chinese_section',
	join('|', N("System"), N("Fonts"), N("Console")) => 'interpreters_section',
	join('|', N("System"), N("Fonts"), N("True type")) => '',
	join('|', N("System"), N("Fonts"), N("Type1")) => '',
	join('|', N("System"), N("Fonts"), N("X11 bitmap")) => '',
	join('|', N("System"), N("Internationalization")) => 'chinese_section',
	join('|', N("System"), N("Kernel and hardware")) => 'hardware_configuration_section',
	join('|', N("System"), N("Libraries")) => '',
	join('|', N("System"), N("Servers")) => '',
	join('|', N("System"),
          #-PO: This is a package/product name. Only translate it if needed:
          N("X11")) => '',
	N("Terminals") => 'terminals_section',
	N("Text tools") => 'text_tools_section',
	N("Toys") => 'toys_section',
	N("Video") => 'video_section',

     # for Mandriva Choice:
	N("Workstation") => 'office_section',
	join('|', N("Workstation"), N("Configuration")) => 'configuration_section',
	join('|', N("Workstation"), N("Console Tools")) => 'interpreters_section',
	join('|', N("Workstation"), N("Documentation")) => 'documentation_section',
	join('|', N("Workstation"), N("Game station")) => 'amusement_section',
	join('|', N("Workstation"), N("Internet station")) => 'networking_section',
	join('|', N("Workstation"), N("Multimedia station")) => 'multimedia_section',
	join('|', N("Workstation"), N("Network Computer (client)")) => 'other_networking',
	join('|', N("Workstation"), N("Office Workstation")) => 'office_section',
	join('|', N("Workstation"), N("Scientific Workstation")) => 'sciences_section',
	N("Graphical Environment") => 'office_section',

	join('|', N("Graphical Environment"), N("GNOME Workstation")) => 'gnome_section',
	join('|', N("Graphical Environment"), N("IceWm Desktop")) => 'icewm',
	join('|', N("Graphical Environment"), N("KDE Workstation")) => 'kde_section',
	join('|', N("Graphical Environment"), N("Other Graphical Desktops")) => 'more_applications_other_section',
	N("Development") => 'development_section',
	join('|', N("Development"), N("Development")) => 'development_section',
	join('|', N("Development"), N("Documentation")) => 'documentation_section',
	N("Server") => 'archiving_section',
	join('|', N("Server"), N("DNS/NIS")) => 'networking_section',
	join('|', N("Server"), N("Database")) => 'databases_section',
	join('|', N("Server"), N("Firewall/Router")) => 'networking_section',
	join('|', N("Server"), N("Mail")) => 'mail_section',
	join('|', N("Server"), N("Mail/Groupware/News")) => 'mail_section',
	join('|', N("Server"), N("Network Computer server")) => 'networking_section',
	join('|', N("Server"), N("Web/FTP")) => 'networking_www_section',

    );


sub ctreefy {
    join('|', map { translate($_) } split m|/|, $_[0]);
}

my $db = open_db();

sub do_search($$$$$$$) {
    my ($find_entry, $tree, $tree_model, $options, $current_search_type, $urpm, $pkgs) = @_;
    my $entry = $find_entry->get_text or return;
    my $entry_rx = eval { qr/$entry/i } or return;
    my ($results_ok, $results_none) = (N("Search results"), N("Search results (none)"));
    $options->{delete_category}->($_) foreach $results_ok, $results_none;
    $options->{state}{flat} and $options->{delete_all}->();
    $tree->collapse_all;
    my @search_results;
    if ($current_search_type ne 'normal') {
	if ($MODE eq 'remove') {
	    if ($current_search_type eq 'descriptions') {
		@search_results = grep { ($pkgs->{$_}{summary} . $pkgs->{$_}{description}) =~ $entry_rx } keys %$pkgs;
	    } else {
		slow_func_statusbar(
		    N("Please wait, searching..."),
		    $w->{real_window},
		    sub {
			$db->traverse(sub {
			    push @search_results, map { if_($_ =~ $entry_rx, urpm_name($_[0])) } $_[0]->files;
			});
			@search_results = grep { exists $pkgs->{$_} } uniq(@search_results);
		    },
		);
	    }
	} else {
	    my @hdlists = map {
		my $h = urpm::media::any_hdlist($_);
		$h =~ s!^file:/+!!;
		if_(!$_->{ignore} && ($MODE ne 'update' || $_->{update}) && -r $h, $h);
	    } @{$urpm->{media}};
	    my $total_size = sum(
		map {
		    my $pack;
		    eval { require MDV::Packdrakeng; $pack = MDV::Packdrakeng->open(archive => $_, quiet => 1) } ? $pack->{toc_f_count} : 0;
		} @hdlists
	    );
	    my $searchstop;
	    my $searchw = ugtk2->new(N("Software Management"), grab => 1, transient => $w->{real_window});
	    gtkadd(
		$searchw->{window},
		gtkpack__(
		    gtknew('VBox', spacing => 5),
		    gtknew('Label', text => N("Please wait, searching...")),
		    my $searchprogress = gtknew('ProgressBar', width => 300),
		    gtkpack__(
			gtknew('HButtonBox', layout => 'spread'),
			gtksignal_connect(
			    Gtk2::Button->new(but(N("Stop"))),
			    clicked => sub { $searchstop = 1 },
			),
		    ),
		),
	    );
	    $searchw->sync;
	    open my $sf, 'parsehdlist --fileswinfo --description --summary ' . join(' ', map { "'$_'" } @hdlists) . ' |';
	    my ($pkg, $progresscount);
	    local $_;
	    while (<$sf>) {
		$searchstop and last;
		if (/^NAME<([^>]+)> VERSION<([^>]+)> RELEASE<([^>]+)> ARCH<([^>]+)>/) {
		    $pkg = "$1-$2-$3.$4";
		    $progresscount++; $progresscount <= $total_size and $searchprogress->set_fraction($progresscount/$total_size);
		    $searchw->flush;
		    next;
		}
		$pkg or next;
		my (undef, $key, $value) = split ':', $_;
		if ($current_search_type eq 'descriptions') {
		    $key =~ /^summary|description$/ or next;
		} else {
		    $key eq 'files' or next;
		}
		if ($value =~ $entry_rx) {
		    exists $pkgs->{$pkg} and push @search_results, $pkg;
		    $pkg = '';
		}
	    }
	    close $sf;
	    @search_results = uniq(@search_results); #- there can be multiple packages with same version/release for different arch's
	    $searchw->destroy;
	}
    } else {
	@search_results = grep { $_ =~ $entry_rx } keys %$pkgs;
    }
    if (@search_results) {
	$options->{add_nodes}->(map { [ $_, N("Search results") . ($options->{tree_mode} eq 'by_presence'
								 ? '|' . ($pkgs->{$_}{pkg}->flag_installed ? N("Upgradable") : N("Addable"))
								 : ($options->{tree_mode} eq 'by_selection'
								    ? '|' . ($pkgs->{$_}{selected} ? N("Selected") : N("Not selected"))
								    : ''))
				      ] } sort { uc($a) cmp uc($b) } @search_results);
	my $last_iter = $tree_model->iter_nth_child(undef, $tree_model->iter_n_children(undef) - 1);
	my $path = $tree_model->get_path($last_iter);
	$tree->expand_row($path, 0);
    	$tree->scroll_to_cell($path, undef, 1, 0.5, 0);
    } else {
	$options->{add_nodes}->([ '', $results_none, { nochild => 1 } ]);
    }
}

package Gtk2::Mdv::TextView;

sub new {
    my ($_class) = @_;
    my $w = mygtk2::gtknew('TextView');
    my $time if 0;
    require Time::HiRes;
    $w->signal_connect(size_allocate => sub {
        my ($w, $requisition) = @_;
        return if !ref($w->{anchors});
        return if Time::HiRes::clock_gettime() - $time < 0.200;
        $time = Time::HiRes::clock_gettime();
        foreach my $anchor (@{$w->{anchors}}) {
            $_->set_size_request($requisition->width-30, -1) foreach $anchor->get_widgets;
        }
        1;
    });
    $w;
}

1;

package main;

sub format_pkg_simplifiedinfo {
    my ($pkgs, $key, $urpm, $descriptions) = @_;
    my ($name, $_version) = split_fullname($key);
    my $medium = pkg2medium($pkgs->{$key}{pkg}, $urpm)->{name};
    my $update_descr = $pkgs->{$key}{pkg}->flag_upgrade && $descriptions->{$name}{pre} && $descriptions->{$name}{medium} eq $medium;
    my $s = ugtk2::markup_to_TextView_format(join("\n", format_header($name . ' - ' . $pkgs->{$key}{summary}) .
      # workaround gtk+ bug where GtkTextView wronly limit embedded widget size to bigger line's width (#25533):
                                                      "\x{200b} \x{feff}" . ' ' x 120,
      if_($update_descr, # is it an update?
	  format_field(N("Importance: ")) . escape_text_for_TextView_markup_format($descriptions->{$name}{importance}),
	  format_field(N("Reason for update: ")) . escape_text_for_TextView_markup_format(rpm_description($descriptions->{$name}{pre})),
      ),
      '')); # extra empty line
    if ($update_descr) {
        push @$s, [ my $link = gtkshow(Gtk2::LinkButton->new($descriptions->{$name}{URL}, N("Security advisory"))) ];
        $link->set_uri_hook(sub {
            my (undef, $url) = @_;
            run_program::raw({ detach => 1 }, 'www-browser', $url);
        });
      }

    push @$s, @{ ugtk2::markup_to_TextView_format(join("\n",
      (escape_text_for_TextView_markup_format($pkgs->{$key}{description} || $descriptions->{$name}{description}) || '<i>' . N("No description") . '</i>')
    )) };
    push @$s, [ "\n" ];
    push @$s, [ gtkadd(gtkshow(my $exp = Gtk2::Expander->new(format_field(N("Files:")))),
                       gtknew('TextView', text => 
                                      exists $pkgs->{$key}{files} ?
                                          ugtk2::markup_to_TextView_format('<tt>' . join("\n", map { "\x{200e}$_" } @{$pkgs->{$key}{files}}) . '</tt>') #- to highlight information
                           : N("(Not available)"),
                   )) ];
    $exp->set_use_markup(1);
    push @$s, [ "\n\n" ];
    push @$s, [ gtkadd(gtkshow(my $exp2 = Gtk2::Expander->new(format_field(N("Changelog:")))),
                       gtknew('TextView', text => $pkgs->{$key}{changelog} || N("(Not available)"))
                   ) ];
    $exp2->set_use_markup(1);
    $s;

}

sub format_pkg_info {
    my ($pkgs, $key, $urpm, $descriptions) = @_;
    my ($name, $version) = split_fullname($key);
    my @files = (
	format_field(N("Files:\n")),
	exists $pkgs->{$key}{files}
	    ? '<tt>' . join("\n", map { "\x{200e}$_" } @{$pkgs->{$key}{files}}) . '</tt>' #- to highlight information
	    : N("(Not available)"),
    );
    my @chglo = (format_field(N("Changelog:\n")), ($pkgs->{$key}{changelog} ? @{$pkgs->{$key}{changelog}} : N("(Not available)")));
    my @source_info = (
	$MODE eq 'remove' || !@$max_info_in_descr
	    ? ()
	    : (
		format_field(N("Medium: ")) . pkg2medium($pkgs->{$key}{pkg}, $urpm)->{name},
		format_field(N("Currently installed version: ")) . find_installed_version($pkgs->{$key}{pkg}),
	    )
    );
    my @max_info = @$max_info_in_descr && $changelog_first ? (@chglo, @files) : (@files, '', @chglo);
    ugtk2::markup_to_TextView_format(join("\n", format_field(N("Name: ")) . $name,
      format_field(N("Version: ")) . $version,
      format_field(N("Architecture: ")) . $pkgs->{$key}{pkg}->arch,
      format_field(N("Size: ")) . N("%s KB", int($pkgs->{$key}{pkg}->size/1024)),
      if_(
	  $MODE eq 'update',
	  format_field(N("Importance: ")) . $descriptions->{$name}{importance}
      ),
      @source_info,
      '', # extra empty line
      format_field(N("Summary: ")) . $pkgs->{$key}{summary},
      '', # extra empty line
      if_(
	  $MODE eq 'update',
	  format_field(N("Reason for update: ")) . rpm_description($descriptions->{$name}{pre}),
      ),
      format_field(N("Description: ")), ($pkgs->{$key}{description} || $descriptions->{$name}{description} || N("No description")),
      @max_info,
    ));
}

sub run_treeview_dialog {
    my ($callback_action) = @_;
    my ($urpm, $pkgs, $descriptions);
    my (%filter_methods, $force_displaying_group, @initial_selection, $initial_selection_done);
    my $switch_pkg_list_mode = sub {
        my ($mode) = @_;
        return if !$mode;
        return if !$filter_methods{$mode};
        $force_displaying_group = 1;
        $filter_methods{$mode}->();
    };
    my $pkgs_provider = sub {
        my ($options, $mode) = @_;
        return if !$mode;
        my $h = &get_pkgs($urpm, $options); # was given (1, @_) for updates
        ($urpm, $descriptions) = @$h{qw(urpm update_descr)};
        %filter_methods = (
            all => sub { $pkgs = { map { %{$h->{$_}} } qw(installed installable updates) } },
            installed => sub { $pkgs = $h->{installed} },
            non_installed => sub { $pkgs = $h->{installable} },
            #mandrake_choices => sub { $pkgs =  },
            all_updates => sub {
                my %pkgs = grep { my $p = $h->{installable}{$_}; $p->{pkg} && !$p->{selected} && $p->{pkg}->flag_installed && $p->{pkg}->flag_upgrade } keys %{$h->{installable}};
                $pkgs = {
                    (map { $_ => $h->{updates}{$_} } keys %{$h->{updates}}),
                    (map { $_ => $h->{installable}{$_} } keys %pkgs)
                };
            },
            #security => sub { $pkgs =  },
            #normal => sub { $pkgs =  }
        );
        if (!$initial_selection_done) {
            $filter_methods{all}->();
            @initial_selection = grep { $pkgs->{$_}{selected} } keys %$pkgs;
            $initial_selection_done = 1;
        }
        foreach my $importance (qw(bugfix security normal)) {
            $filter_methods{$importance} = sub {
                $pkgs = $h->{updates};
                $pkgs = { map { $_ => $pkgs->{$_} } grep { 
                    my ($name, $_version) = split_fullname($_);
                    $descriptions->{$name}{importance} eq $importance } keys %$pkgs };
            };
        }
        $filter_methods{mandrake_choices} = $filter_methods{non_installed};
        $switch_pkg_list_mode->($mode);
    };

    my ($options, $size_selected, $compssUsers, $tree, $tree_model, $detail_list, $detail_list_model, %elems);
    my (undef, $size_free) = MDK::Common::System::df('/usr');

    $w = ugtk2->new(N("Software Management"));
    $::main_window = $w->{real_window};

    my $is_locale_available = sub {
	any { $urpm->{depslist}[$_]->flag_selected } keys %{$urpm->{provides}{$_[0]} || {}} and return 1;
	my $found;
	$db->traverse_tag('name', [ $_ ], sub { $found ||= 1 });
	return $found;
    };
    my $callback_choices = sub {
	my (undef, undef, undef, $choices) = @_;
	foreach my $pkg (@$choices) {
	    foreach ($pkg->requires_nosense) {
		/locales-/ or next;
		$is_locale_available->($_) and return $pkg;
	    }
	}
	my $callback = sub { interactive_msg(N("More information on package..."), $options->{get_info}->($_[0]), scroll => 1) };
	$choices = [ sort { $a->name cmp $b->name } @$choices ];
	my @choices = interactive_list_(N("Please choose"), P("The following package is needed:", "One of the following packages is needed:", scalar(@$choices)),
                                     [ map { urpm_name($_) } @$choices ], $callback);
     $choices->[$choices[0]];
    };

    my $closure_removal = sub {
        $urpm->{state} = {};
        urpm::select::find_packages_to_remove($urpm, $urpm->{state}, \@_);
    };
    my $force_rebuild;
    $options = {
	is_a_package => sub {
         my ($pkg) = @_;
         return exists $pkgs->{$pkg};
     },
	get_icon => sub {
         my ($group, $parent) = @_;
         my $pixbuf;
         my $path = $group =~ /\|/ ? '/usr/share/icons/mini/' : '/usr/share/icons/';
         my $create_pixbuf = sub { gtknew('Pixbuf', file => join('', $path, $_[0], '.png')) };
         eval { $pixbuf = $create_pixbuf->($group_icons{$group}) };
         eval { $pixbuf ||= $create_pixbuf->($group_icons{$parent}) } if $parent;
         $pixbuf ||= $create_pixbuf->('applications_section');
     },
	node_state => sub {
         my $pkg = $pkgs->{$_[0]};
         my $urpm_obj = $pkg->{pkg};
	    $_[0] ? $pkg->{selected} ?
                    ($urpm_obj->flag_installed ? ($urpm_obj->flag_upgrade ? 'to_install' : 'to_remove') : 'to_install')
                      : ($urpm_obj->flag_installed ? 
                           ($urpm_obj->flag_upgrade ? 'to_update' : 'installed')
                             : ($urpm_obj->flag_base ? '/usr/share/rpmdrake/icons/base.png' : 'uninstalled')) : 'XXX';
	},  #- checks $_[0] -> hack for partial tree displaying
	build_tree => sub {
	    my ($add_node, $flat, $mode) = @_;
	    my $old_mode if 0;
	    $mode = $options->{rmodes}{$mode} || $mode;
	    return if $old_mode eq $mode && !$force_rebuild;
	    $old_mode = $mode;
	    undef $force_rebuild;
	    my @elems;
	    my $wait; $wait = statusbar_msg(N("Please wait, listing packages...")) if $MODE ne 'update';
	    gtkflush();
	    if ($mode eq 'mandrake_choices') {
		foreach my $pkg (keys %$pkgs) {
		    my ($name) = split_fullname($pkg);
		    push @elems, [ $pkg, $_ ] foreach @{$compssUsers->{$name}};
		}
	    } else {
		my @keys = keys %$pkgs;
		if (member($mode, qw(all_updates security bugfix normal))) {
		    @keys = grep {
			my ($name) = split_fullname($_);
			member($descriptions->{$name}{importance}, @$mandrakeupdate_wanted_categories)
			|| ! $descriptions->{$name}{importance};
		    } @keys;
		    if (@keys == 0) {
			$add_node->('', N("(none)"), { nochild => 1 });
			my $explanation_only_once if 0;
			$explanation_only_once or interactive_msg(N("No update"),
N("The list of updates is empty. This means that either there is
no available update for the packages installed on your computer,
or you already installed all of them."));
			$explanation_only_once = 1;
		    }
		}
		@elems = map { [ $_, !$flat && ctreefy($pkgs->{$_}{pkg}->group) ] } @keys;
	    }
	    my %sortmethods = (
		by_size => sub { sort { $pkgs->{$b->[0]}{pkg}->size <=> $pkgs->{$a->[0]}{pkg}->size } @_ },
		by_selection => sub { sort { $pkgs->{$b->[0]}{selected} <=> $pkgs->{$a->[0]}{selected}
			|| uc($a->[0]) cmp uc($b->[0]) } @_ },
		by_leaves => sub {
		    my $pkgs_times = 'rpm -q --qf "%{name}-%{version}-%{release} %{installtime}\n" `urpmi_rpm-find-leaves`';
		    sort { $b->[1] <=> $a->[1] } grep { exists $pkgs->{$_->[0]} } map { [ split ] } run_rpm($pkgs_times);
		},
		flat => sub { no locale; sort { uc($a->[0]) cmp uc($b->[0]) } @_ },
		by_medium => sub { sort { $a->[2] <=> $b->[2] || uc($a->[0]) cmp uc($b->[0]) } @_ },
	    );
	    if ($flat) {
		$add_node->($_->[0], '') foreach $sortmethods{$mode || 'flat'}->(@elems);
	    } else {
		if (0 && $MODE eq 'update') {
		    $add_node->($_->[0], N("All")) foreach $sortmethods{flat}->(@elems);
		    $tree->expand_row($tree_model->get_path($tree_model->get_iter_first), 0);
		} elsif ($mode eq 'by_source') {
		    $add_node->($_->[0], $_->[1]) foreach $sortmethods{by_medium}->(map {
			my $m = pkg2medium($pkgs->{$_->[0]}{pkg}, $urpm); [ $_->[0], $m->{name}, $m->{priority} ];
		    } @elems);
		} elsif ($mode eq 'by_presence') {
		    $add_node->(
			$_->[0], $pkgs->{$_->[0]}{pkg}->flag_installed && !$pkgs->{$_->[0]}{pkg}->flag_skip
			? N("Upgradable") : N("Addable")
		    ) foreach $sortmethods{flat}->(@elems);
		} else {
		    #- we populate all the groups tree at first
		    %elems = ();
		    # better loop on packages, create groups tree and push packages in the proper place:
		    foreach my $pkg (@elems) {
                  my $grp = $pkg->[1];
                  $options->{add_parent}->($grp);
                  $elems{$grp} ||= [];
                  push @{$elems{$grp}}, $pkg;
		    }
		}
	    }
	    statusbar_msg_remove($wait) if defined $wait;
	},
	grep_unselected => sub { grep { exists $pkgs->{$_} && !$pkgs->{$_}{selected} } @_ },
	partialsel_unsel => sub {
	    my ($unsel, $sel) = @_;
	    @$sel = grep { exists $pkgs->{$_} } @$sel;
	    @$unsel < @$sel;
	},
	toggle_nodes => sub {
	    my ($set_state, $old_state, @nodes) = @_;
	    @nodes = grep { exists $pkgs->{$_} } @nodes
		or return;
	    #- avoid selecting too many packages at once
	    return if !$dont_show_selections && @nodes > 2000;
	    my $new_state = !$pkgs->{$nodes[0]}{selected};

	    my @nodes_with_deps;
	    my $deps_msg = sub {
		return 1 if $dont_show_selections;
		my ($title, $msg, $nodes, $nodes_with_deps) = @_;
		my @deps = sort { $a cmp $b } difference2($nodes_with_deps, $nodes);
		@deps > 0 or return 1;
		deps_msg_again:
		my $results = interactive_msg(
		    $title, $msg . urpm::select::translate_why_removed($urpm, $urpm->{state}, @deps),
		    yesno => [ N("Cancel"), N("More info"), N("Ok") ],
		    scroll => 1,
		);
		if ($results eq
		    #-PO: Keep it short, this is gonna be on a button
		    N("More info"))
		{
		    interactive_packtable(
			N("Information on packages"),
			$w->{real_window},
			undef,
			[ map { my $pkg = $_;
			    [ gtknew('HBox', children_tight => [ gtkset_selectable(gtknew('Label', text => $pkg), 1) ]),
			    gtknew('Button', text => N("More information on package..."), 
				clicked => sub {
				    interactive_msg(N("More information on package..."), $options->{get_info}->($pkg), scroll => 1);
				}) ] } @deps ],
			[ gtknew('Button', text => N("Ok"), 
			    clicked => sub { Gtk2->main_quit }) ]
		    );
		    goto deps_msg_again;
		} else {
		    return $results eq N("Ok");
		}
	    }; # deps_msg

	    if (member($old_state, qw(to_remove installed))) {  # remove pacckages
		if ($new_state) {
		    my @remove;
		    slow_func($tree->window, sub { @remove = $closure_removal->(@nodes) });
		    @nodes_with_deps = grep { !$pkgs->{$_}{selected} && !/^basesystem/ } @remove;
		    $deps_msg->(N("Some additional packages need to be removed"),
			formatAlaTeX(N("Because of their dependencies, the following package(s) also need to be\nremoved:")) . "\n\n",
			\@nodes, \@nodes_with_deps) or @nodes_with_deps = ();
		    my @impossible_to_remove;
		    foreach (grep { exists $pkgs->{$_}{base} } @remove) {
			${$pkgs->{$_}{base}} == 1 ? push @impossible_to_remove, $_ : ${$pkgs->{$_}{base}}--;
		    }
		    @impossible_to_remove and interactive_msg(N("Some packages can't be removed"),
			N("Removing these packages would break your system, sorry:\n\n") .
			formatlistpkg(@impossible_to_remove));
		    @nodes_with_deps = difference2(\@nodes_with_deps, \@impossible_to_remove);
		} else {
		    slow_func($tree->window,
			sub { @nodes_with_deps = grep { intersection(\@nodes, [ $closure_removal->($_) ]) }
			    grep { $pkgs->{$_}{selected} && !member($_, @nodes) } keys %$pkgs });
		    push @nodes_with_deps, @nodes;
		    $deps_msg->(N("Some packages can't be removed"),
			N("Because of their dependencies, the following package(s) must be\nunselected now:\n\n"),
			\@nodes, \@nodes_with_deps) or @nodes_with_deps = ();
		    $pkgs->{$_}{base} && ${$pkgs->{$_}{base}}++ foreach @nodes_with_deps;
		}
	    } else {
		if ($new_state) {
		    if (@nodes > 1) {
			#- unselect i18n packages of which locales is not already present (happens when user clicks on KDE group)
			my @bad_i18n_pkgs;
			foreach my $sel (@nodes) {
			    foreach ($pkgs->{$sel}{pkg}->requires_nosense) {
				/locales-([^-]+)/ or next;
				$sel =~ /-$1[-_]/ && !$is_locale_available->($_) and push @bad_i18n_pkgs, $sel;
			    }
			}
			@nodes = difference2(\@nodes, \@bad_i18n_pkgs);
		    }
		    my @requested;
		    slow_func(
			$tree->window,
			sub {
			    @requested = $urpm->resolve_requested(
				$db, $urpm->{state},
				{ map { $pkgs->{$_}{pkg}->id => 1 } @nodes },
				callback_choices => $callback_choices,
			    );
			},
		    );
		    @nodes_with_deps = map { urpm_name($_) } @requested;
		    if (!$deps_msg->(N("Additional packages needed"),
			    N("To satisfy dependencies, the following package(s) also need\nto be installed:\n\n"),
			    \@nodes, \@nodes_with_deps))
		    {
			@nodes_with_deps = ();
			$urpm->disable_selected($db, $urpm->{state}, @requested);
			goto packages_selection_ok;
		    }

		    if (my @cant = sort(difference2(\@nodes, \@nodes_with_deps))) {
			my @ask_unselect = urpm::select::unselected_packages($urpm, $urpm->{state});
			my @reasons = map {
			    my $cant = $_;
			    my $unsel = find { $_ eq $cant } @ask_unselect;
			    $unsel
			    ? join("\n", urpm::select::translate_why_unselected($urpm, $urpm->{state}, $unsel))
			    : ($pkgs->{$_}{pkg}->flag_skip ? N("%s (belongs to the skip list)", $cant) : $cant);
			} @cant;
			my $count = @reasons;
			interactive_msg(
			    P("One package cannot be installed", "Some packages can't be installed", $count),
			    P("Sorry, the following package cannot be selected:\n\n%s", "Sorry, the following packages can't be selected:\n\n%s", $count, join("\n", @reasons)),
			    scroll => 1,
			);
			foreach (@cant) {
			    $pkgs->{$_}{pkg}->set_flag_requested(0);
			    $pkgs->{$_}{pkg}->set_flag_required(0);
			}
		    }
		    packages_selection_ok:
		} else {
		    my @unrequested;
		    slow_func($tree->window,
			sub { @unrequested = $urpm->disable_selected($db, $urpm->{state},
				map { $pkgs->{$_}{pkg} } @nodes) });
		    @nodes_with_deps = map { urpm_name($_) } @unrequested;
		    if (!$deps_msg->(N("Some packages need to be removed"),
			    N("Because of their dependencies, the following package(s) must be\nunselected now:\n\n"),
			    \@nodes, \@nodes_with_deps))
		    {
			@nodes_with_deps = ();
			$urpm->resolve_requested($db, $urpm->{state}, { map { $_->id => 1 } @unrequested });
			goto packages_unselection_ok;
		    }
		    packages_unselection_ok:
		}
	    }

	    foreach (@nodes_with_deps) {
		#- some deps may exist on some packages which aren't listed because
		#- not upgradable (older than what currently installed)
		exists $pkgs->{$_} or next;
          if (!$pkgs->{$_}{pkg}) { #- can't be removed  # FIXME; what about next packages in the loop?
              $pkgs->{$_}{selected} = 0;
              log::explanations("can't be removed: $_");
          } else {
              $pkgs->{$_}{selected} = $new_state;
          }
		$set_state->($_, $options->{node_state}($_), $detail_list_model);
		$pkgs->{$_}{pkg}
		    and $size_selected += $pkgs->{$_}{pkg}->size * ($new_state ? 1 : -1);
	    }
	}, #- toggle_nodes
	get_status => sub {
	    member($default_list_mode, qw(all non_installed))
		? N("Selected: %s / Free disk space: %s", formatXiB($size_selected), formatXiB($size_free*1024))
		: N("Selected size: %d MB", $size_selected/(1024*1024));
	},
	get_info => sub {
	    my ($key) = @_;
	    #- the package information hasn't been loaded. Instead of rescanning the media, just give up.
	    exists $pkgs->{$key} or return [ [ N("Description not available for this package\n") ] ];
	    exists $pkgs->{$key}{description} && exists $pkgs->{$key}{files}
		or slow_func($tree->window, sub { extract_header($pkgs->{$key}, $urpm) });
	    my $s;
         eval { $s = format_pkg_simplifiedinfo($pkgs, $key, $urpm, $descriptions) };
         if (my $err = $@) {
             $s = N("A fatal error occurred: %s.", $err);
         }
         $s;
	},
	check_interactive_to_toggle => sub { 1 },
	grep_allowed_to_toggle => sub { @_ },
	rebuild_tree => sub {},
    };

    $tree_model = Gtk2::TreeStore->new("Glib::String", "Glib::String", "Gtk2::Gdk::Pixbuf");
    $tree_model->set_sort_column_id(0, 'ascending');
    $tree = Gtk2::TreeView->new_with_model($tree_model);
    $tree->get_selection->set_mode('browse');

    $tree->append_column(Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::MDV::CellRendererPixWithLabel->new, 'pixbuf' => 2, label => 0));
    $tree->append_column(Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::CellRendererText->new, 'text' => 1));
    $tree->set_headers_visible(0);

    $detail_list_model = Gtk2::ListStore->new("Glib::String", "Gtk2::Gdk::Pixbuf", "Glib::String");
    $detail_list = Gtk2::TreeView->new_with_model($detail_list_model);
    $detail_list->append_column(my $pixcolumn  = Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::CellRendererPixbuf->new, 'pixbuf' => 1));
    $pixcolumn->{is_pix} = 1;
    $detail_list->append_column(Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::CellRendererText->new, 'text' => 0));
    $detail_list_model->set_sort_column_id(0, 'ascending');
    $detail_list->set_headers_visible(0);
    $detail_list->set_rules_hint(1);

    ($typical_width) = string_size($tree, translate("Graphical Environment") . "xmms-more-vis-plugins");
    $typical_width > 600 and $typical_width = 600;  #- try to not being crazy with a too large value
    $typical_width < 150 and $typical_width = 150;
    #- XXX : work around bug in gtk2 that clobbers display (see bugzilla #16575)
    #$textcolumn->set_min_width($typical_width*0.7);

    my $cursor_to_restore;
    $_->signal_connect(
	expose_event => sub {
	    $cursor_to_restore or return;
	    gtkset_mousecursor_normal($tree->window);
	    undef $cursor_to_restore;
	},
    ) foreach $tree, $detail_list;
    $tree->get_selection->signal_connect(changed => sub {
        my ($model, $iter) = $_[0]->get_selected;
        return if !$iter;
        my $current_group if 0;
        my $new_group = $model->get($iter, 0);
        return if $current_group eq $new_group && !$force_displaying_group;
        undef $force_displaying_group;
        $current_group = $new_group;
        $model && $iter or return;
        my $group = $model->get($iter, 0);
        my $parent = $iter;
        while ($parent = $model->iter_parent($parent)) {
            $group = join('|', $model->get($parent, 0), $group);
        }
        slow_func($tree->window, sub { $options->{add_nodes}->(@{$elems{$group}}) });
    });

    $options->{state}{splited} = 1;
    #$options->{state}{flat} = 1;
    $compssUsers = parse_compssUsers_flat();
    my %modes = (all => N("All"), installed => N("Installed"), non_installed => N("Non installed"),
                 mandrake_choices => $rpmdrake::branded ? N("%s choices", $rpmdrake::distrib{system}) : N("Mandriva Linux choices"),
                 if_(0, # let's keep the translated strings (to be resurected as sorting the treeview):
                     N("All packages, alphabetical"),
                     by_presence => N("All packages, by update availability"),
                     by_size => N("All packages, by size"),
                     by_selection => N("All packages, by selection state"),
                     by_leaves => N("Leaves only, sorted by install date"),
                     by_group => N("All packages, by group"),
                 ),
                 all_updates => N("All updates"), security => N("Security updates"), bugfix => N("Bugfixes updates"), normal => N("Normal updates")
             );
    my %rmodes = reverse %modes;
    $options->{rmodes} = \%rmodes;

    my %default_mode = (install => 'all', # we want the new GUI by default instead of "non_installed"
                        remove => 'installed',
                        update => 'security',
                    );
    my %wanted_categories = (
        all_updates => [ qw(security bugfix normal) ],
        security => [ 'security' ],
        bugfix => [ 'bugfix' ],
        normal => [ 'normal' ],
    );
    my $reset_search;
    my $old_value;
    my $cbox = gtksignal_connect(Gtk2::ComboBox->new_with_strings([ @modes{ 'all', if_($compssUsers, 'mandrake_choices'),
                                                                              qw(installed non_installed all_updates security bugfix normal)
                                                                          } ],
                                                                  $modes{$default_mode{$MODE} || 'all'}),
                                 changed => sub {
                                     my $val = $_[0]->get_text;
                                     return if $val eq $old_value; # workarounding gtk+ sending us sometimes twice events
                                     $old_value = $val;
                                     $default_list_mode = $rmodes{$val};
                                     if (my @cat = $wanted_categories{$rmodes{$val}} && @{$wanted_categories{$rmodes{$val}}}) {
                                         @$mandrakeupdate_wanted_categories = @cat;
                                     }
                                     if (0) {
                                         $reset_search->();
                                         $options->{rebuild_tree}->();
                                     }
                                     $options->{state}{flat} = 0; # was 1 only for the "All packages, alphabetical", "All packages, by size", "All packages, by selection state", and "Leaves only, sorted by install date"

                                     if ($options->{tree_mode} ne $val) {
                                         ($options->{tree_mode}) = $val =~ /^by/ ?
                                           $options->{tree_submode} : $rmodes{$val};
                                         $tree_mode->[0] = $options->{tree_mode};
                                         $tree_flat->[0] = $options->{state}{flat};
                                         $reset_search->();
                                         slow_func($::main_window->window, sub { $switch_pkg_list_mode->($rmodes{$val}) });
                                         $options->{rebuild_tree}->();
                                     }
                                 }
                             );
    my $default_radio = $options->{tree_mode} = $default_list_mode;
    $cbox->set_text($modes{$default_radio});

	my $radio_by;
	$options->{tree_submode} ||= $default_radio;
	$options->{tree_subflat} ||= $options->{state}{flat};

    my @search_types = qw(normal descriptions files);
    my $current_search_type = $search_types[0];
    my $search_types_optionmenu = Gtk2::ComboBox->new;
    {
	$search_types_optionmenu->set_model(Gtk2::ListStore->new('Glib::String'));
	my $search_types_renderer = Gtk2::CellRendererText->new;
	$search_types_optionmenu->pack_start($search_types_renderer, 0);
	$search_types_optionmenu->set_attributes($search_types_renderer, text => 0);
	my $iter = $search_types_optionmenu->get_model->iter_nth_child(undef, 0);
	$iter = $search_types_optionmenu->get_model->insert(0);
	$search_types_optionmenu->get_model->set($iter, 0, N("in names"));
	$iter = $search_types_optionmenu->get_model->insert(1);
	$search_types_optionmenu->get_model->set($iter, 0, N("in descriptions"));
	$iter = $search_types_optionmenu->get_model->insert(2);
	$search_types_optionmenu->get_model->set($iter, 0, N("in file names"));
	$search_types_optionmenu->set_active(0);
	$search_types_optionmenu->signal_connect(
	    changed => sub {
		$current_search_type = $search_types[$search_types_optionmenu->get_active];
	    },
	);
    }

    my $info = Gtk2::Mdv::TextView->new;
    $info->set_left_margin(2);
    $info->set_right_margin(15);  #- workaround when right elevator of scrolled window appears

    my $find_entry;
    my $clear_button;
    my $find_callback = sub {
	$clear_button and $clear_button->set_sensitive(1);
	do_search($find_entry, $tree, $tree_model, $options, $current_search_type, $urpm, $pkgs);
    };
    $reset_search = sub {
	$clear_button and $clear_button->set_sensitive(0);
	$find_entry and $find_entry->set_text("");
    };

    my $do_action = sub {
        require urpm::sys;
        if (!urpm::sys::check_fs_writable()) {
            $urpm->{fatal}(1, N("Error: %s appears to be mounted read-only.", $urpm::sys::mountpoint));
            return;
        }
	if (!int(grep { $pkgs->{$_}{selected} } keys %$pkgs)) {
	    interactive_msg(N("You need to select some packages first."), N("You need to select some packages first."));
            return;
        }
	my $size_added = sum(map { if_($_->flag_selected && !$_->flag_installed, $_->size) } @{$urpm->{depslist}});
	if ($MODE eq 'install' && $size_free - $size_added/1024 < 50*1024) {
	    interactive_msg(N("Too many packages are selected"),
N("Warning: it seems that you are attempting to add so much
packages that your filesystem may run out of free diskspace,
during or after package installation ; this is particularly
dangerous and should be considered with care.

Do you really want to install all the selected packages?"), yesno => 1)
	      or return;
	}
	if (!$callback_action->($urpm, $pkgs)) {
	    $force_rebuild = 1;
	    $pkgs_provider->({ skip_updating_mu => 1 }, $options->{tree_mode});
	    $reset_search->();
	    $size_selected = 0;
	    (undef, $size_free) = MDK::Common::System::df('/usr');
	    $options->{rebuild_tree}->();
            gtktext_insert($info, '');
	}
    };

    my $hpaned = gtknew('HPaned',
                        child1 => gtknew('ScrolledWindow', child => $tree, width => $typical_width*0.9) , resize1 => 0, shrink1 => 0,
                        resize2 => 1, shrink2 => 0,
                        child2 => gtknew('VPaned',
                                         child1 => gtknew('ScrolledWindow', child => $detail_list), resize1 => 1, shrink1 => 0,
                                         child2 => gtknew('ScrolledWindow', child => $info), resize2 => 1, shrink2 => 0
                                     )
                    );

    my $status = gtknew('Label');
    my $checkbox_show_autoselect;
    my ($menu, $factory) = create_factory_menu(
	$w->{real_window},
	[ N("/_File"), undef, undef, undef, '<Branch>' ],
	if_(
	    ! $>,
	    [ N("/_File") . N("/_Update media"), undef, sub {
		update_sources_interactive($urpm, transient => $w->{real_window})
		    and do {
			$force_rebuild = 1;
			$pkgs_provider->({ skip_updating_mu => 1 }, $options->{tree_mode});
			$reset_search->();
			$size_selected = 0;
			$options->{rebuild_tree}->();
		    };
	    }, undef, '<Item>' ]
	),
	[ N("/_File") . N("/_Reset the selection"), undef, sub {
	    if ($MODE ne 'remove') {
		$urpm->disable_selected(
		    $db, $urpm->{state},
		    map { if_($pkgs->{$_}{selected}, $pkgs->{$_}{pkg}) } keys %$pkgs,
		);
	    }
	    $pkgs->{$_}{selected} = 0 foreach keys %$pkgs;
	    $reset_search->();
	    $size_selected = 0;
	    $force_displaying_group = 1;
	    $tree->get_selection->signal_emit('changed');
	}, undef, '<Item>' ],
	[ N("/_File") . N("/Reload the _packages list"), undef, sub {
	    slow_func($::main_window->window, sub {
                       $force_rebuild = 1;
                       $rmodes{$pkgs_provider->({ skip_updating_mu => 1 }, $options->{tree_mode})};
                   });
	    $reset_search->();
	    $size_selected = 0;
	    $options->{rebuild_tree}->();
	}, undef, '<Item>' ],
	[ N("/_File") . N("/_Quit"), N("<control>Q"), sub { Gtk2->main_quit }, undef, '<Item>', ],
	#[ N("/_View"), undef, undef, undef, '<Branch>' ],
	if_(!$>,
	    [ N("/_Options"), undef, undef, undef, '<Branch>' ],
	    [ N("/_Options") . N("/_Media Manager"), undef, sub {
               run_program::raw({ detach => 1 }, 'edit-urpm-sources.pl');
           }, undef, '<Item>' ],
	    [ N("/_Options") . N("/_Show automatically selected packages"), undef, sub {
		$dont_show_selections = !$checkbox_show_autoselect->get_active;
	    }, undef, '<CheckItem>' ],
	),
	[ N("/_Help"), undef, undef, undef, '<Branch>' ],
     [ N("/_Help") . N("/_Report Bug"), undef, sub { run_program::raw({ detach => 1 }, 'drakbug', '--report', 'rpmdrake') }, undef, '<Item>' ],
	[ N("/_Help") . N("/_Help"), undef, sub { rpmdrake::open_help($MODE) }, undef, '<Item>' ],
     [ N("/_Help") . N("/_About..."), undef, sub {
         my $license = formatAlaTeX(translate($::license));
         $license =~ s/\n/\n\n/sg; # nicer formatting
         my $w = gtknew('AboutDialog', name => N("Rpmdrake"),
                        version => '2007',
                        copyright => N("Copyright (C) %s by Mandriva", '2002-2006'),
                        license => $license, wrap_license => 1,
                        comments => N("Rpmdrake is Mandriva Linux package management tool."),
                        website => 'http://mandrivalinux.com',
                        website_label => N("Mandriva Linux"),
                        authors => 'Thierry Vignaud <vignaud@mandriva.com>',
                        artists => 'Hélène Durosini <ln@mandriva.com>',
                        translator_credits =>
                          #-PO: put here name(s) and email(s) of translator(s) (eg: "John Smith <jsmith@nowhere.com>")
                          N("_: Translator(s) name(s) & email(s)\n"),
                        transient_for => $::main_window, modal => 1, position_policy => 'center-on-parent',
                    );
         $w->show_all;
         $w->run;
       }, undef, '<Item>'
     ]

    );
    $checkbox_show_autoselect = $factory->get_widget("<main>" . strip_first_underscore(N("/_Options"), N("/_Show automatically selected packages")))
	and $checkbox_show_autoselect->set_active(!$dont_show_selections);
    gtkadd(
	$w->{window},
	gtkpack_(
	    gtknew('VBox', spacing => 3),
	    0, $menu,
	    0, getbanner(),
	    1, gtkadd(
		gtknew('Frame', border_width => 3, shadow_type => 'none'),
		gtkpack_(
		    gtknew('VBox', spacing => 3),
		    0, gtkpack__(
			gtknew('HBox', spacing => 10),
			$cbox,
			gtknew('Label', text => N("Find:")),
			$search_types_optionmenu,
			gtksignal_connect(
			    $find_entry = gtknew('Entry'),
			    key_press_event => sub {
				$_[1]->keyval == $Gtk2::Gdk::Keysyms{Return}
				    and $find_callback->();
			    },
			),
			gtksignal_connect(Gtk2::Button->new(but(N("Search"))), clicked => $find_callback),
			gtksignal_connect(
			    $clear_button = Gtk2::Button->new(but(N("Clear"))),
			    clicked => sub { $reset_search->() },
			),
		    ),
		    1, $hpaned,
		    0, $status,
		    0, gtkpack_(
			gtknew('HBox', spacing => 20),
			0, gtksignal_connect(
			    Gtk2::Button->new(but_(N("Help"))),
			    clicked => sub { rpmdrake::open_help($MODE) },
			),
               1, gtknew('Label'),
			0, gtksignal_connect(
			    Gtk2::Button->new(but_(N("Select all"))),
			    clicked => sub {
                       return if !ref($options->{toggle_all});
                       $options->{toggle_all}->(1);
                   },
			),
			0, my $action_button = gtksignal_connect(
			    Gtk2::Button->new(but_(N("Apply"))),
			    clicked => sub { $do_action->() },
			),
			0, gtksignal_connect(
			    Gtk2::Button->new(but_(N("Quit"))),
			    clicked => sub { Gtk2->main_quit },
			),
		    ),
		),
	    ),
	    0, $statusbar = Gtk2::Statusbar->new,
	),
    );
    $action_button->set_sensitive(0) if $>;
    $clear_button->set_sensitive(0);
    $find_entry->grab_focus;

    gtktext_insert($info, [ 
        [ $info->render_icon('gtk-dialog-info', 'GTK_ICON_SIZE_DIALOG', undef) ],
        @{ ugtk2::markup_to_TextView_format(
            formatAlaTeX(join("\n\n\n", format_header(N("Quick Introduction")),
                              N("You can browse the packages through the categories tree on the left."),
                              N("You can view information about a package by clicking on it on the right list."),
                              N("To install, update or remove a package, just click on its \"checkbox\"."))))
      }
    ]);

    $w->{rwindow}->set_default_size($typical_width*2.7, 500) if !$::isEmbedded;
    $find_entry->set_text($options{search}[0]) if $options{search};

    $w->{rwindow}->show_all;
    $w->{rwindow}->set_sensitive(0);

    $pkgs_provider->({}, $default_list_mode); # default mode
    if (@initial_selection) {
        $options->{initial_selection} = \@initial_selection;
        $pkgs->{$_}{selected} = 0 foreach @initial_selection;
    }

    $w->{rwindow}->set_sensitive(1);

    $options->{widgets} = {
	w => $w,
	tree => $tree,
	tree_model => $tree_model,
	detail_list_model => $detail_list_model,
	detail_list => $detail_list,
	info => $info,
	status => $status,
    };
    $options->{init_callback} = $find_callback if $options{search};

    $treeview_dialog_run = 1;
    ask_browse_tree_info_given_widgets_for_rpmdrake($options);
}


# -=-=-=---=-=-=---=-=-=-- main -=-=-=---=-=-=---=-=-=-

if ($options{'merge-all-rpmnew'}) {
    my %pkg2rpmnew;
    my $wait = wait_msg(N("Please wait, searching..."));
    print "Searching .rpmnew and .rpmsave files...\n";
    $db->traverse(sub {
		     my $n = my_fullname($_[0]);
		     $pkg2rpmnew{$n} = [ grep { m|^/etc| && (-r "$_.rpmnew" || -r "$_.rpmsave") } map { chomp_($_) } $_[0]->files ];
		 });
    print "done.\n";
    undef $wait;
    $typical_width = 330;
    dialog_rpmnew('', %pkg2rpmnew) and print "Nothing to do.\n";
    myexit(0);
}

readconf();

init();

if ($MODE eq 'remove') {
    run_treeview_dialog(\&perform_removal);
} else {
    run_treeview_dialog(\&perform_installation);
}

writeconf();

myexit(0);
