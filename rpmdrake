#!/usr/bin/perl
#*****************************************************************************
# 
#  Copyright (c) 2002 Guillaume Cottenceau (gc at mandrakesoft dot com)
# 
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License version 2, as
#  published by the Free Software Foundation.
# 
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
# 
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
# 
#*****************************************************************************
#
# $Id$

BEGIN {  #- we want to run this code before the Gtk->init of the use-my_gtk
    my $basename = sub { local $_ = shift; s|/*\s*$||; s|.*/||; $_ };
    "@ARGV" =~ /-h/ and do {
	printf STDERR "Usage: %s [OPTION]...
  --no-confirmation      don't ask first confirmation question in MandrakeUpdate mode
  --no-verify-rpm        don't verify packages signatures
  --changelog-first      display changelog before filelist in the description window
  --merge-all-rpmnew     propose to merge all .rpmnew/.rpmsave files found
", $basename->($0);
	exit 0;
    };
}

use strict;
use vars qw($MODE %options);

use lib qw(/usr/lib/libDrakX);
use common;
use rpmdrake;
use gurpm;

eval { require ugtk2; ugtk2->import(qw(:all)) };
if ($@) {
    print "This program cannot be run in console mode.\n";
    c::_exit(0);  #- skip ugtk2::END
}

$MODE = 'install';
$0 =~ m|/rpmdrake-remove$| and $MODE = 'remove';
$0 =~ m|/MandrakeUpdate$|  and $MODE = 'update';

/^-?-(\S+)$/ and $options{$1} = 1 foreach @ARGV;


$::isStandalone = 1;

my $w;
sub interactive_msg_  {  interactive_msg(@_, if_(exists $w->{rwindow}, transient => $w->{rwindow})) };
sub interactive_list_ { interactive_list(@_, if_(exists $w->{rwindow}, transient => $w->{rwindow})) };
sub wait_msg_         {         wait_msg(@_, if_(exists $w->{rwindow}, transient => $w->{rwindow})) };

$> and interactive_msg_(N("Running in user mode"),
N("You are launching this program as a normal user.
You will not be able to perform modifications on the system,
but you may still browse the existing database."), yesno => 1, text => { yes => N("Ok"), no => N("Cancel") }) or myexit(0);


sub ctreefy { $_[0] =~ s,/,|,g; $_[0] }

sub beautify_description {
    my ($t, $tmp);
    foreach (split "\n", $_[0]) {
	s/^\s*//;
        if (/^$/ || /^\s*(-|\*|\+|o)\s/) {
            $t || $tmp and $t .= "$tmp\n";
            $tmp = $_;
        } else {
            $tmp = ($tmp ? "$tmp " : ($t && "\n") . $tmp) . $_;
        }
    }
    "$t$tmp\n";
}

sub myformatList {
    my $r = formatList(40, @_);
    $r =~ s/(.{50}\S*)\s/$1\n/g;
    $r
}

sub split_fullname { $_[0] =~ /^(.*)-([^-]+-[^-]+)$/ }
sub my_fullname { my ($name, $version, $release) = $_[0]->fullname; "$name-$version-$release" }
sub urpm_name { my ($name, $version, $release, $arch) = $_[0]->fullname; "$name-$version-$release.$arch" }

sub parse_compssUsers_flat {
    my (%compssUsers, $category);
    my $compss = '/var/lib/urpmi/compssUsers.flat';
    -r $compss or $compss = '/usr/share/rpmdrake/compssUsers.flat.default';
    -r $compss or die "Internal error, please report";
    foreach (cat_($compss)) {
	s/#.*//;
	/^\s*$/ and next;
	if (/^\S/) {
	    if (/^(.+?) \[icon=.+?\] \[path=(.+?)\]/) {
		$category = translate($2).'|'.translate($1);
	    } else {
		print STDERR "Malformed category in compssUsers.flat: <$_>\n";
	    }
	} elsif (/^\t(\d) (\S+)\s*$/) {
	    $category or print STDERR "Entry without category <$_>\n";
	    push @{$compssUsers{$2}}, $category . ($1 <= 3 ? '|'.N("Other") : '');
	}
    }
    \%compssUsers;
}

sub pkg2medium {
    my ($p, $urpm) = @_;
    my $tmp;
    each_index { !$_->{ignore} && $p->id <= $_->{end} and $tmp ||= ${$urpm->{media}}[$::i] } @{$urpm->{media}};
    $tmp;
}

sub extract_header {
    my ($pkg, $urpm) = @_;
    my $chg_prepro = sub {
	#- preprocess changelog for faster TextView insert reaction
	[ map { [ "$_\n", if_(/^\*/, { 'weight' => Gtk2::Pango->WEIGHT_BOLD }) ] } split("\n", $_[0]) ]
    };
    if ($MODE eq 'remove') {
	@$max_info_in_descr or return;
	my $name = my_fullname($pkg->{pkg});
	add2hash($pkg, { files => chomp_(scalar(`rpm -ql $name`)) || N("(none)"),
                         changelog => $chg_prepro->(scalar(`LC_ALL=C rpm -q --changelog $name`)) });
    } else {
	my ($p, $medium) = ($pkg->{pkg}, pkg2medium($pkg->{pkg}, $urpm));
	my $hdlist =  "$urpm->{statedir}/$medium->{hdlist}";
	if (-r $hdlist) {  #- packdrake segfaults when giving a missing file :(
	    standalone::explanations("Extracting header of " . $p->header_filename . " from $hdlist");
	    my $packer;
	    eval { $packer = new packdrake($hdlist, quiet => 1) } or log::l("Warning, hdlist seems corrupted :-("), goto header_non_available;
            my $headersdir = chomp_(`mktemp -d /tmp/rpmdrake.XXXXXX`);
            -d $headersdir or die "Could not create temporary directory";
	    $packer->extract_archive($headersdir, $p->header_filename);
	    $p->update_header("$headersdir/" . $p->header_filename) or log::l("Warning, could not extract header!"), goto header_non_available;
	    rm_rf($headersdir);
	    add2hash($pkg, { summary => $p->summary, description => beautify_description($p->description) });
	    my $localtime2changelog = sub { scalar(localtime($_[0])) =~ /(.*) \S+ (\d{4})$/ && "$1 $2" };
	    @$max_info_in_descr and add2hash($pkg, {
	        files => join("\n", $p->files) || N("(none)"),
		changelog => $chg_prepro->(join("\n", mapn { "* ".$localtime2changelog->($_[2])." $_[0]\n\n$_[1]\n" }
						[ $p->changelog_name ], [ $p->changelog_text ], [ $p->changelog_time ])) });
	    $p->pack_header;
	} else {
	  header_non_available:
	    add2hash($pkg, { summary => N("(Not available)"), description => undef });
	}
    }
}

sub db { URPM::DB::open or die 'Couldn\'t open RPM DB' }

sub do_search($$$$$$$) {
    my ($find_entry, $tree, $tree_model, $options, $current_search_type, $urpm, $pkgs) = @_;
    my $entry = $find_entry->get_text or return;
    my ($results_ok, $results_none) = (N("Search results"), N("Search results (none)"));
    $options->{delete_category}->($_) foreach $results_ok, $results_none;
    $options->{state}{flat} and $options->{delete_all}->();
    $tree->collapse_all;
    my @search_results;
    if ($current_search_type ne 'normal') {
	if ($MODE eq 'remove') {
	    if ($current_search_type eq 'descriptions') {
		@search_results = map { if_(eval { ($pkgs->{$_}{summary}.$pkgs->{$_}{description}) =~ /$entry/i }, $_) } keys %$pkgs;
	    } else {
		slow_func(N("Please wait, searching..."),
			  sub { db->traverse(sub { push @search_results, map { if_(eval { /$entry/i }, my_fullname($_[0])) } $_[0]->files });
				@search_results = grep { exists $pkgs->{$_} } uniq(@search_results) });
	    }
	} else {
	    my @hdlists = map { my $h = "$urpm->{statedir}/$_->{hdlist}";
				if_(!$_->{ignore} && (!($MODE eq 'update') || $_->{update}) && -r $h, $h) } @{$urpm->{media}};
	    my $total_size = sum(map { my $pack; eval { $pack = new packdrake($_, quiet => 1) } ? $pack->{toc_f_count} : 0 } @hdlists);
	    my $searchstop;
	    my $searchw = ugtk2->new('rpmdrake', grab => 1, transient => $w->{rwindow});
	    gtkadd($searchw->{window}, gtkpack__(Gtk2::VBox->new(1, 5),
						 Gtk2::Label->new(N("Please wait, searching...")),
						 my $searchprogress = gtkset_size_request(Gtk2::ProgressBar->new, 400, -1),
						 gtkpack__(gtkset_layout(Gtk2::HButtonBox->new, 'spread'),
							   gtksignal_connect(Gtk2::Button->new(but(N("Stop"))),
									     clicked => sub { $searchstop = 1 }))));
	    $searchw->sync;
	    local *SF;
	    open SF, 'parsehdlist --fileswinfo --description --summary '.join(' ', map { "'$_'" } @hdlists).' |';
	    my ($pkg, $progresscount);
	    while (<SF>) {
		$searchstop and last;
		if (/^NAME<([^>]+)> VERSION<([^>]+)> RELEASE<([^>]+)>/) {
		    $pkg = "$1-$2-$3";
		    $progresscount++; $progresscount <= $total_size and $searchprogress->set_fraction($progresscount/$total_size);
		    $searchw->flush;
		    next;
		}
		$pkg or next;
		my (undef, $key, $value) = split ':', $_;
		if ($current_search_type eq 'descriptions') {
		    $key =~ /^summary|description$/ or next;
		} else {
		    $key eq 'files' or next;
		}
		if (eval { $value =~ /$entry/i }) {
		    exists $pkgs->{$pkg} and push @search_results, $pkg;
		    $pkg = '';
		}
	    }
	    close SF;
	    @search_results = uniq(@search_results); #- there can be multiple packages with same version/release for different arch's
	    $searchw->destroy;
	}
    } else {
	@search_results = grep { eval { /$entry/i } } keys %$pkgs;
    }
    if (@search_results) {
	$options->{add_nodes}->(map { [ $_, N("Search results").($options->{tree_mode} eq 'by_presence'
								 ? '|'.($pkgs->{$_}{pkg}->flag_installed ? N("Upgradable") : N("Addable"))
								 : ($options->{tree_mode} eq 'by_selection'
								    ? '|'.($pkgs->{$_}{selected} ? N("Selected") : N("Not selected"))
								    : ''))
				      ] } sort { uc($a) cmp uc($b) } @search_results);
	my $last_iter = $tree_model->iter_nth_child(undef, $tree_model->iter_n_children(undef) - 1);
	my $path = $tree_model->get_path($last_iter);
	$tree->expand_row($path, 0);
	$path->free; $last_iter->free;
    } else {
	$options->{add_nodes}->([ '', $results_none, { nochild => 1 } ]);
    }
}

sub find_installed_version {
    my ($p) = @_;
    my @version;
    db->traverse_tag('name', [ $p->name ], sub { push @version, $_[0]->version.'-'.$_[0]->release });
    @version ? join(',', sort @version) : N("(none)");
}

#- remove architecture
sub ask_remove_ {
    my ($state) = @_;
    map { /(.*)\.[^\.]+$/ && $1 } keys %{$state->{ask_remove}};
}

sub run_treeview_dialog {
    my ($pkgs_provider, $callback_action) = @_;

    my ($urpm, $pkgs, $descriptions) = $pkgs_provider->();

    my ($options, $size_selected, $compssUsers, $info, $info_update, $tree, $disable_treeselect_callback, %elems);
    $size_selected = 0;  #- to remove the use strict warning
    my (undef, $size_free) = MDK::Common::System::df('/usr');

    $::noBorder = 1;
    $w = ugtk2->new(N("rpmdrake")." 9.1");
    $::noBorder = 0;

    my $formatlistpkg = sub { myformatList(sort { uc($a) cmp uc($b) } @_) };
    my $is_locale_available = sub {
	grep { $urpm->{depslist}[$_]->flag_selected } keys %{$urpm->{provides}{$_[0]} || {}} and return 1;
	my $found;
	db->traverse_tag('name', [ $_ ], sub { $found ||= 1 });
	return $found;
    };
    my $callback_choices = sub {
	my (undef, $db, $state, $choices) = @_;
	foreach my $pkg (@$choices) {
	    foreach ($pkg->requires_nosense) {
		/locales-/ or next;
		$is_locale_available->($_) and return $pkg;
	    }
	}
	my $callback = sub { interactive_msg_(N("More information on package..."), $options->{get_info}->($_[0]), scroll => 1) };
	$choices->[interactive_list_(N("Please choose"), N("One of the following packages is needed:"),
				     [ map { my_fullname($_) } @$choices ], $callback)];
    };
    my $choices_auto;
    my $callback_choices_auto = sub {
	my (undef, $db, $state, $choices) = @_;
	member(my_fullname($_), @$choices_auto) and return $_ foreach @$choices;
	return $choices->[0];  #- theoretically unreachable, but at least try to fallback on something usable
    };
    my $closure_removal = sub {
	$urpm->{state}{ask_remove} = {};
	my $db = db();
	foreach (@_) {
	    $db->traverse_tag('name', [ (split_fullname($_))[0] ], sub {
				  my_fullname($_[0]) eq $_ or return;
				  $urpm->resolve_closure_ask_remove($db, $urpm->{state}, $_[0]);
			      }) or die N("unknown package ") . "$_\n";
	}
	ask_remove_($urpm->{state});
    };
    $options = {
		   node_state => sub { $_[0] ? ($pkgs->{$_[0]}{selected} ? 'selected' : 'unselected')
					     : 'XXX' },  #- checks $_[0] -> hack for partial tree displaying
		   build_tree => sub {
		       my ($add_node, $flat, $mode) = @_;
		       my @elems;
		       my $wait = wait_msg_(N("Please wait, listing packages..."));
		       $disable_treeselect_callback = 1;
		       if ($mode eq 'mandrake_choices') {
			   foreach my $pkg (keys %$pkgs) {
			       my ($name) = split_fullname($pkg);
			       push @elems, [ $pkg, $_ ] foreach @{$compssUsers->{$name}};
			   }
		       } else {
			   my @keys = keys %$pkgs;
			   if ($MODE eq 'update') {
			       @keys = grep { my ($name) = split_fullname($_);
					      member($descriptions->{$name}{importance}, @$mandrakeupdate_wanted_categories) } @keys;
			       if (@keys == 0) {
				   $add_node->('', N("(none)"), { nochild => 1 });
				   my $explanation_only_once if 0;
				   $explanation_only_once or interactive_msg_(N("No update"),
N("The list of updates is void. This means that either there is
no available update for the packages installed on your computer,
or you already installed all of them."));
				   $explanation_only_once = 1;
			       }
			   }
			   @elems = map { [ $_, !$flat && ctreefy($pkgs->{$_}{pkg}->group) ] } @keys;
		       }
		       my %sortmethods = (by_size => sub { sort { $pkgs->{$b->[0]}{pkg}->size <=> $pkgs->{$a->[0]}{pkg}->size } @_ },
					  by_selection => sub { sort { $pkgs->{$b->[0]}{selected} <=> $pkgs->{$a->[0]}{selected}
								       || uc($a->[0]) cmp uc($b->[0]) } @_ },
                                          by_leaves => sub {
                                              my @pkgs_times = qx{rpm -q --qf "%{name}-%{version}-%{release} %{installtime}\n" `urpmi_rpm-find-leaves`};
                                              sort { $b->[1] <=> $a->[1] } grep { exists $pkgs->{$_->[0]} } map { [ split ] } @pkgs_times;
                                          },
					  flat => sub { sort { uc($a->[0]) cmp uc($b->[0]) } @_ });
		       if ($flat) {
			   $add_node->($_->[0], '') foreach $sortmethods{$mode || 'flat'}->(@elems);
		       } else {
			   if ($mode eq 'by_source') {
			       $add_node->($_->[0], pkg2medium($pkgs->{$_->[0]}{pkg}, $urpm)->{name}) foreach $sortmethods{flat}->(@elems);
			   } elsif ($mode eq 'by_presence') {
			       $add_node->($_->[0], $pkgs->{$_->[0]}{pkg}->flag_installed && !$pkgs->{$_->[0]}{pkg}->flag_skip
                                                    ? N("Upgradable") : N("Addable"))
				 foreach $sortmethods{flat}->(@elems);
			   } else {
			       #- special case, we don't populate all the tree at first (to speed things up)
			       %elems = ();
			       foreach my $root (sort { $a cmp $b } uniq(map { ($_->[1] =~ /([^\|]+)\|?/)[0] } @elems)) {
				   $add_node->('', $root);
				   @{$elems{$root}} = sort { $a->[1] cmp $b->[1] || uc($a->[0]) cmp uc($b->[0]) }
				                      grep { $_->[1] =~ /^\Q$root|\E?/ } @elems;
			       }
			   }
		       }
		       $disable_treeselect_callback = 0;
		       remove_wait_msg($wait);
		   },
		   grep_unselected => sub { grep { exists $pkgs->{$_} && !$pkgs->{$_}{selected} } @_ },
		   partialsel_unsel => sub {
		       my ($unsel, $sel) = @_;
		       @$sel = grep { exists $pkgs->{$_} } @$sel;
		       @$unsel < @$sel;
		   },
		   toggle_nodes => sub {
		       my ($set_state, @nodes) = @_;
		       @nodes = grep { exists $pkgs->{$_} } @nodes;
		       int(@nodes) or return;
		       my $new_state = !$pkgs->{$nodes[0]}{selected};

		       my @nodes_with_deps;
		       my $deps_msg = sub {
			   my ($title, $msg, $nodes, $nodes_with_deps) = @_;
			   my @deps = sort { $a cmp $b } difference2($nodes_with_deps, $nodes);
			   @deps > 0 or return 1;
			 deps_msg_again:
			   my $results = interactive_msg_($title, $msg . $formatlistpkg->(@deps),
							  yesno => [ N("Ok"), N("More info"), N("Cancel") ]);
			   if ($results eq 
			                   #-PO: Keep it short, this is gonna be on a button
			                   N("More info")) {
			       interactive_packtable(N("Information on packages"),
						     $w->{rwindow},
						     undef,
						     [ map { my $pkg = $_;
							     [ gtkpack__(Gtk2::HBox->new(0, 0), gtkset_selectable(Gtk2::Label->new($pkg), 1)),
							       gtksignal_connect(Gtk2::Button->new(N("More information on package...")),
										 clicked => sub {
										     interactive_msg(N("More information on package..."),
											      $options->{get_info}->($pkg), scroll => 1)
										 }) ] } @deps ],
						     [ gtksignal_connect(Gtk2::Button->new(N("Ok")),
									 clicked => sub { Gtk2->main_quit }) ]);
			       goto deps_msg_again;
			   } else {
			       return $results eq N("Ok");
			   }
		       };
		       if ($MODE eq 'remove') {
			   if ($new_state) {
			       slow_func($tree->window, sub { $closure_removal->(@nodes) });
			       @nodes_with_deps = grep { !$pkgs->{$_}{selected} && !/^basesystem/ } ask_remove_($urpm->{state});
			       $deps_msg->(N("Some additional packages need to be removed"),
					   N("Because of their dependencies, the following package(s) also need to be\nremoved:\n\n"),
					   \@nodes, \@nodes_with_deps) or @nodes_with_deps = ();
			       my @impossible_to_remove;
			       foreach (grep { exists $pkgs->{$_}{base} } ask_remove_($urpm->{state})) {
				   ${$pkgs->{$_}{base}} == 1 ? push @impossible_to_remove, $_ : ${$pkgs->{$_}{base}}--;
			       }
			       @impossible_to_remove and interactive_msg_(N("Some packages can't be removed"),
									  N("Removing these packages would break your system, sorry:\n\n") .
									  $formatlistpkg->(sort { $a cmp $b } @impossible_to_remove));
			       @nodes_with_deps = difference2(\@nodes_with_deps, \@impossible_to_remove);
			   } else {
			       slow_func($tree->window,
					 sub { @nodes_with_deps = grep { intersection(\@nodes, [ $closure_removal->($_) ]) }
						                  grep { $pkgs->{$_}{selected} } keys %$pkgs });
			       $deps_msg->(N("Some packages can't be removed"),
					   N("Because of their dependencies, the following package(s) must be\nunselected now:\n\n"),
					   \@nodes, \@nodes_with_deps) or @nodes_with_deps = ();
			       $pkgs->{$_}{base} && ${$pkgs->{$_}{base}}++ foreach @nodes_with_deps;
			   }
		       } else {
			   if ($new_state) {
			       $urpm->{state}{selected} = {};
			       if (@nodes > 1) {
				   #- unselect i18n packages of which locales is not already present (happens when user clicks on KDE group)
				   my @bad_i18n_pkgs;
				   foreach my $sel (@nodes) {
				       foreach ($pkgs->{$sel}{pkg}->requires_nosense) {
					   /locales-([^-]+)/ or next;
					   $sel =~ /-$1[-_]/ && !$is_locale_available->($_) and push @bad_i18n_pkgs, $sel;
				       }
				   }
				   @nodes = difference2(\@nodes, \@bad_i18n_pkgs);
			       }
			       slow_func($tree->window,
					 sub { $urpm->resolve_requested(db(), $urpm->{state}, { map { $pkgs->{$_}{pkg}->id => 1 } @nodes },
							   callback_choices => $callback_choices, no_flag_update => 1, keep_state => 1) });
                               my @conflict;
			       my $pkg_sel_after_selection = sub {
                                   if (%{$urpm->{state}{ask_unselect} || {}}) {
                                       foreach my $p (keys %{$urpm->{state}{ask_unselect}}) {
                                           push @conflict, [ my_fullname($urpm->{depslist}[$p]),
                                                             [ map { my_fullname($urpm->{depslist}[$_]) } keys %{$urpm->{state}{ask_unselect}{$p}} ] ];
                                       }
                                       delete @{$urpm->{state}{selected}}{keys %{delete $urpm->{state}{ask_unselect}}};
                                   }
 				   @nodes_with_deps = map { my_fullname($urpm->{depslist}[$_]) } keys %{$urpm->{state}{selected}};
			       };
			       $pkg_sel_after_selection->();
			       if (!$deps_msg->(N("Additional packages needed"), 
						N("To satisfy dependencies, the following package(s) also need\nto be installed:\n\n"),
						\@nodes, \@nodes_with_deps)) {
				   @nodes_with_deps = ();
				   goto packages_selection_ok;
			       }

			       $choices_auto = \@nodes_with_deps;
			       $urpm->{state}{selected} = {};
			       slow_func($tree->window,
					 sub { $urpm->resolve_requested(db(), $urpm->{state}, { map { $pkgs->{$_}{pkg}->id => 1 } @nodes },
									callback_choices => $callback_choices_auto) });
			       $pkg_sel_after_selection->();
			       if (my @cant = difference2(\@nodes, \@nodes_with_deps)) {
				   interactive_msg_(N("Some packages can't be installed"),
						    N("Sorry, the following package(s) can't be selected:\n\n%s\n\nReasons follow:\n\n%s",
                                                      $formatlistpkg->(@cant),
                                                      join '', map { N("%s conflicts with %s", $_->[0], join(', ', @{$_->[1]})) } @conflict));
				   foreach (@cant) {
				       $pkgs->{$_}{pkg}->set_flag_requested(0);
				       $pkgs->{$_}{pkg}->set_flag_required(0);
				   }
			       }
			     packages_selection_ok:
			   } else {
			       $urpm->{state}{unselected} = {};
			       slow_func($tree->window,
					 sub { $urpm->resolve_unrequested(db(), $urpm->{state},
									  { map { $pkgs->{$_}{pkg}->id => undef } @nodes },
									  no_flag_update => 1) });
			       @nodes_with_deps = map { my_fullname($urpm->{depslist}[$_]) } keys %{$urpm->{state}{unselected}};
			       if (!$deps_msg->(N("Some packages need to be removed"),
						N("Because of their dependencies, the following package(s) must be\nunselected now:\n\n"),
						\@nodes, \@nodes_with_deps)) {
				   @nodes_with_deps = ();
				   goto packages_unselection_ok;
			       }
			       slow_func($tree->window,
					 sub { $urpm->resolve_unrequested(db(), $urpm->{state},
									  { map { $pkgs->{$_}{pkg}->id => undef } @nodes }) });
			       @nodes_with_deps = map { my_fullname($urpm->{depslist}[$_]) } keys %{$urpm->{state}{unselected}};
			     packages_unselection_ok:
			   }
		       }

		       foreach (@nodes_with_deps) {
			   exists $pkgs->{$_} or next;  #- some deps may exist on some packages which aren't listed because
			                                #- not upgradable (older than what currently installed)
			   $set_state->($_, $new_state ? 'selected' : 'unselected');
			   $pkgs->{$_}{selected} = $new_state;
			   $size_selected += $pkgs->{$_}{pkg}->size * ($new_state ? 1 : -1);
		       }
		   },
		   get_status => sub { $MODE eq 'install' ? N("Selected: %d MB / Free disk space: %d MB",
							      $size_selected/(1024*1024), $size_free/1024)
					                  : N("Selected size: %d MB", $size_selected/(1024*1024)) },
		   get_info => sub { my ($key) = @_;
				     exists $pkgs->{$key} or return;  #- related to the partial tree displaying hackery ($key can be '')
				     my ($name, $version) = split_fullname($key);
				     exists $pkgs->{$key}{description} && (!@$max_info_in_descr || exists $pkgs->{$key}{files})
				       or slow_func($tree->window, sub { extract_header($pkgs->{$key}, $urpm) });
				     my $tag_tag = { 'foreground' => 'royalblue3', 'weight' => Gtk2::Pango->WEIGHT_BOLD };
				     my $tag_fix = { 'font' => 'monospace' };
				     my @files = ([ N("Files:\n"), $tag_tag ], [ $pkgs->{$key}{files} || N("(Not available)"), $tag_fix ]);
				     my @chglo = ([ N("Changelog:\n"), $tag_tag ], @{$pkgs->{$key}{changelog} || [[ N("(Not available)") ]]});
				     my @source_info = ($MODE eq 'remove' || !@$max_info_in_descr ? ()
							: ([ N("Media: "), $tag_tag ],
							   [ pkg2medium($pkgs->{$key}{pkg}, $urpm)->{name} ], [ "\n" ],
							   [ N("Currently installed version: "), $tag_tag ],
							   [ find_installed_version($pkgs->{$key}{pkg}) ], [ "\n" ]));
				     my @max_info = if_(@$max_info_in_descr, $options{'changelog-first'} ? (@chglo, [ "\n" ], @files)
                                                                                                         : (@files, [ "\n\n" ], @chglo));
				     [ [ N("Name: "),    $tag_tag ], [ "$name\n" ],
				       [ N("Version: "), $tag_tag ], [ "$version\n" ],
				       [ N("Size: "),    $tag_tag ], [ N("%s KB", int($pkgs->{$key}{pkg}->size/1024))."\n" ],
				       if_($MODE eq 'update',
					   [ N("Importance: "), $tag_tag ], [ "$descriptions->{$name}{importance}\n" ]),
                                       @source_info,
				       [ "\n".N("Summary: "),   $tag_tag ], [ "$pkgs->{$key}{summary}\n\n" ],
                                       if_($MODE eq 'update',
                                           [ N("Reason for update: "), $tag_tag ],
                                           [ beautify_description($descriptions->{$name}{pre})."\n" ]),
				       [ N("Description: "),    $tag_tag ], [ "$pkgs->{$key}{description}\n" ],
				       @max_info ];
				 },
		   check_interactive_to_toggle => sub { 1 },
		   grep_allowed_to_toggle => sub { @_ },
		   rebuild_tree => sub {},
		  };

    my $tree_model = Gtk2::TreeStore->new(Gtk2::GType->STRING, Gtk2::GType->OBJECT, Gtk2::GType->STRING);
    $tree = Gtk2::TreeView->new_with_model($tree_model);
    $tree->get_selection->set_mode('browse');
    $tree->append_column(my $textcolumn = Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::CellRendererText->new, 'text' => 0));
    $tree->append_column(my $pixcolumn  = Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::CellRendererPixbuf->new, 'pixbuf' => 1));
    $tree->append_column(Gtk2::TreeViewColumn->new_with_attributes(undef, Gtk2::CellRendererText->new, 'text' => 2));
    $tree->set_headers_visible(0);
    $tree->set_rules_hint(1);

    ($typical_width) = string_size($tree, translate("Graphical Environment")."xmms-more-vis-plugins");
    $typical_width > 500 and $typical_width = 500;  #- try to not being crazy with a too large value
    $typical_width < 150 and $typical_width = 150;
    $textcolumn->set_min_width($typical_width*0.7);
    $textcolumn->set_max_width($typical_width);

    my $cursor_to_restore;
    $tree->signal_connect(expose_event => sub {
			      $cursor_to_restore or return;
			      gtkset_mousecursor_normal($tree->window);
			      undef $cursor_to_restore;
			  });
    $tree->signal_connect(row_expanded => sub { 
			      my ($tree, $iter, $path) = @_;
			      #- hackish: if first child has '' as name, then we need to expand on the fly
			      my $child = $tree_model->iter_children($iter);
			      if ($tree_model->get($child, 0) eq '') {
				  $tree_model->remove($child);
				  slow_func($tree->window, sub { $options->{add_nodes}->(@{$elems{$tree_model->get($iter, 0)}}) });
			      } else {
				  if ($tree_model->iter_n_children($iter) > 500) { #- populating large groups is slow
				      $cursor_to_restore = 1;
				      gtkset_mousecursor_wait($tree->window);
				  }
			      }
			      $child->free;
			      $tree->expand_row($path, 0);
			  });

    my @modes_buttons;
    if ($MODE eq 'update') {
	$options->{state}{flat} = 1;
	my %toggle_infos = (security => N("Security updates"), bugfix => N("Bugfixes updates"), normal => N("Normal updates"));
	my @toggle_names_ordered = qw(security bugfix normal);
	@modes_buttons = map { Gtk2::CheckButton->new(but($toggle_infos{$_})) } @toggle_names_ordered;
	mapn {
	    member($_[0], @$mandrakeupdate_wanted_categories) and $_[1]->set_active(1);
	    my $capture_value = $_[0];
	    $_[1]->signal_connect(clicked => sub {
				      $disable_treeselect_callback = 1;
				      if ($_[0]->get_active) {
					  push @$mandrakeupdate_wanted_categories, $capture_value;
				      } else {
					  @$mandrakeupdate_wanted_categories = difference2($mandrakeupdate_wanted_categories,
											   [ $capture_value ]);
				      }
				      $options->{rebuild_tree}->();
				      $disable_treeselect_callback = 0;
				  });
	} \@toggle_names_ordered, \@modes_buttons;
    } else {
	my %radios_infos = (mandrake_choices => { name => N("Mandrake choices"),           flat => 0 },
			    flat             => { name => N("All packages, alphabetical"), flat => 1 },
	                    by               => { name => '',                              flat => 0 });
	$compssUsers = parse_compssUsers_flat();
	my @radios_names_ordered = qw(mandrake_choices flat by);
	$compssUsers or shift @radios_names_ordered;
	@modes_buttons = gtkradio($radios_infos{mandrake_choices}{name}, map { $radios_infos{$_}{name} } @radios_names_ordered);

	mapn {
	    my $capture_mode = $_[0];
	    $_[1]->signal_connect(clicked => sub {
				      if ($_[0]->get_active) {
					  $disable_treeselect_callback = 1;
					  ($options->{tree_mode}, $options->{state}{flat}) = $capture_mode eq 'by'
					        ? ($options->{tree_submode}, $options->{tree_subflat})
					        : ($capture_mode,            $radios_infos{$capture_mode}{flat});
					  $options->{rebuild_tree}->();
					  $disable_treeselect_callback = 0;
				      }
				  });
	} \@radios_names_ordered, \@modes_buttons;
	$options->{tree_mode} = $radios_names_ordered[0];

	my $advanced_menu = Gtk2::Menu->new;
	my $radio_by;
	my @advanced_modes = ([ 'by_group', N("All packages, by group"), 0 ], [ 'by_size', N("All packages, by size"), 1 ],
			      [ 'by_selection', N("All packages, by selection state"), 1 ]);
	$MODE eq 'install' and push @advanced_modes, ([ 'by_source', N("All packages, by media repository"), 0 ], [ 'by_presence', N("All packages, by update availability"), 0 ]);
	$MODE eq 'remove' and push @advanced_modes, [ 'by_leaves', N("Leaves only, sorted by install date"), 1 ];
	foreach (@advanced_modes) {
	    my ($capt_mode, $capt_flat) = ($_->[0], $_->[2]);
	    $advanced_menu->append(gtksignal_connect(gtkshow(Gtk2::MenuItem->new_with_label($_->[1])),
						     activate => sub {
							 $options->{tree_submode} = $capt_mode;
							 $options->{tree_subflat} = $capt_flat;
							 $radio_by->activate;
						     }));
	}
	$options->{tree_submode} = $advanced_modes[0][0];
	each_index {
	    if ($_ eq 'by') {
		$radio_by = $modes_buttons[$::i];
		$modes_buttons[$::i] = gtkpack(Gtk2::HBox->new(0, 0), $modes_buttons[$::i], my $t = Gtk2::OptionMenu->new);
		$t->set_menu($advanced_menu);
	    }
	} @radios_names_ordered;
    }

    my $search_types_menu = Gtk2::Menu->new;
    my @search_types = ([ 'normal', N("in names") ], [ 'descriptions', N("in descriptions") ], [ 'files', N("in files") ]);
    my $current_search_type = $search_types[0][0];
    foreach (@search_types) {
	my $capt_type = $_->[0];
	$search_types_menu->append(gtksignal_connect(gtkshow(Gtk2::MenuItem->new_with_label($_->[1])),
						     activate => sub { $current_search_type = $capt_type }));
    }
    my $search_types_optionmenu = Gtk2::OptionMenu->new;
    $search_types_optionmenu->set_menu($search_types_menu);

    my $menu_treeview = Gtk2::Menu->new;
    my @menu_treeview_actions = ([ 'reset_selection', N("Reset the selection") ], [ 'reload_pkg', N("Reload the packages list") ]);
    $MODE ne 'remove' and push @menu_treeview_actions, [ 'update_sources', N("Update media(s)") ];
    foreach (@menu_treeview_actions) {
	my ($action, $text) = @$_;
	my %action2fun; %action2fun = (
		          reset_selection => sub {
			      if ($MODE ne 'remove') {
				  $urpm->{state}{unselected} = {};
				  $urpm->resolve_unrequested(db(), $urpm->{state},
						   { map { if_($pkgs->{$_}{selected}, $pkgs->{$_}{pkg}->id => undef) } keys %$pkgs });
			      }
			      $pkgs->{$_}{selected} = 0 foreach keys %$pkgs;
			      $size_selected = 0;
			      $options->{rebuild_tree}->();
			  },
		          reload_pkg => sub {
			      ($urpm, $pkgs, $descriptions) = $pkgs_provider->({ skip_updating_mu => 1 });
			      $size_selected = 0;
			      $options->{rebuild_tree}->();
			  },
			  update_sources => sub { update_sources_interactive($urpm, transient => $w->{rwindow})
						    and $action2fun{reload_pkg}->() });
	$menu_treeview->append(gtksignal_connect(gtkshow(Gtk2::MenuItem->new_with_label($text)), activate => sub { $action2fun{$action}->() }));
    }
    $tree->signal_connect(button_press_event => sub { $_[1]->button == 3 or return 0;
						      $menu_treeview->popup(undef, undef, undef, undef, $_[1]->button, $_[1]->time) });

    my @menu_descr_modes = ([ N("Normal information"), [] ], [ N("Maximum information"), [1] ]);
    my @descr_modes = gtkradio($menu_descr_modes[@$max_info_in_descr ? 1 : 0][0], map { $_->[0] } @menu_descr_modes);
    mapn {
	my $val = $_[1][1];
	$_[0]->signal_connect(clicked => sub {
				  if ($_[0]->get_active) {
				      $max_info_in_descr = $val;
				      $options->{display_info}->();
				  }
			      });
    } \@descr_modes, \@menu_descr_modes;
    $info = Gtk2::TextView->new;
    $info->set_left_margin(2);
    $info->set_right_margin(15);  #- workaround when right elevator of scrolled window appears

    my $find_entry;
    my $find_callback = sub { do_search($find_entry, $tree, $tree_model, $options, $current_search_type, $urpm, $pkgs) };

    my $do_action = sub {
	if (!int(grep { $pkgs->{$_}{selected} } keys %$pkgs)) {
	    interactive_msg_(N("You need to select some packages first."), N("You need to select some packages first."));
            return;
        }
	my $size_added = sum(map { if_($_->flag_selected && !$_->flag_installed, $_->size) } @{$urpm->{depslist}});
	if ($MODE eq 'install' && $size_free - $size_added/1024 < 50*1024) {
	    interactive_msg_(N("Too many packages are selected"),
N("Warning: it seems that you are attempting to add so much
packages that your filesystem may run out of free diskspace,
during or after package installation ; this is particularly
dangerous and should be considered with care.

Do you really want to install all the selected packages?"), yesno => 1)
	      or return;
	}
	if ($MODE ne 'remove' && %{$urpm->{state}{ask_remove} || {}}) {
	    interactive_msg_(N("Some packages need to be removed"),
N("The following packages have to be removed for others to be upgraded:

%s

Is it ok to continue?", $formatlistpkg->(sort { $a cmp $b } keys %{$urpm->{state}{ask_remove}})), yesno => 1)
	      or return;
	}
	if (!$callback_action->($urpm, $pkgs)) {
	    ($urpm, $pkgs, $descriptions) = $pkgs_provider->({ skip_updating_mu => 1 });
	    $size_selected = 0;
	    (undef, $size_free) = MDK::Common::System::df('/usr');
	    $options->{rebuild_tree}->();
	}
    };

    my $table = Gtk2::Table->new(0, 0, 0);
    $table->attach(gtkpack__(Gtk2::HBox->new(0, 0), gtkpack(Gtk2::VBox->new(0, 0), @modes_buttons)),
		   0, 1, 0, 1, 'fill', 'fill', 0, 0);
    $table->attach(gtkpack__(Gtk2::HBox->new(0, 0), gtkpack(Gtk2::VBox->new(0, 0), Gtk2::Label->new, @descr_modes)),
		   1, 2, 0, 1, 'fill', 'fill', 0, 0);
    $table->attach(gtkadd(gtkset_shadow_type(Gtk2::Frame->new, 'in'),
			  gtkset_size_request(create_scrolled_window($tree), $typical_width*1.25, -1)),
		   0, 1, 1, 2, 'fill', 'fill', 0, 0);
    $table->attach(create_scrolled_window($info),
		   1, 2, 1, 2, ['expand', 'fill'], ['expand', 'fill'], 0, 0);
    gtkadd($w->{window}, 
	   gtkpack_(Gtk2::VBox->new(0, 3),
		    0, gtkset_size_request(my $darea = Gtk2::DrawingArea->new, -1, 76),
		    1, gtkadd(gtkset_shadow_type(gtkset_border_width(Gtk2::Frame->new, 3), 'none'),
			      gtkpack_(Gtk2::VBox->new(0, 3),
				       0, gtkpack__(Gtk2::HBox->new(0, 10),
						    Gtk2::Label->new(N("Find:")),
						    $search_types_optionmenu,
						    gtksignal_connect($find_entry = Gtk2::Entry->new,
							      key_press_event => sub { $_[1]->keyval == Gtk2::Gdk::Event::Key->Sym_Return
											 and $find_callback->() }),
						    gtksignal_connect(Gtk2::Button->new(but(N("Search"))), clicked => $find_callback)),
				       1, $table,
				       0, gtkpack_(Gtk2::HBox->new(0, 20),
						   0, gtksignal_connect(Gtk2::Button->new(but(N("Help"))),
									clicked => sub {
                                                           system('drakhelp Drakxtools-Guide.html/software-management.html &');
                                                           interactive_msg_(N("Help launched in background"),
                                                                            N("The help window has been started, it should appear shortly on your desktop."));
                                                                        }),
						   1, my $status = Gtk2::Label->new,
						   0, gtkpack(Gtk2::HBox->new(1, 20),
                                                              my $action_button = gtksignal_connect(Gtk2::Button->new(but_($MODE eq 'remove' ? N("Remove") : N("Install"))),
                                                                                                    clicked => sub { $do_action->() }),
							      gtksignal_connect(Gtk2::Button->new(but_(N("Quit"))),
										clicked => sub { Gtk2->main_quit })))
				       ))));
    $> and $action_button->set_sensitive(0);
    my $pixbuf_icon = gtkcreate_pixbuf("title-$MODE");
    $darea->modify_font(Gtk2::Pango::FontDescription->from_string('Sans Italic 24'));
    my %t = (remove => N("Software Packages Removal"), update => N("Mandrake Update"), install => N("Software Packages Installation"));
    my $layout = $darea->create_pango_layout($t{$MODE});
    $darea->signal_connect(realize => sub { set_back_pixbuf($darea, gtkcreate_pixbuf('title-tile')) });
    $darea->signal_connect(expose_event => sub {
		       my (undef, undef, $dx, $dy) = $darea->allocation->values;
		       $darea->window->draw_pixbuf($darea->style->white_gc, $pixbuf_icon,
						   0, 0, $dx - $pixbuf_icon->get_width, 0, -1, -1, 'none', 0, 0);
		       my ($lx, $ly) = $layout->get_pixel_size;
		       $darea->window->draw_layout($darea->style->white_gc, ($dx-$lx)/2, ($dy-$ly)/2, $layout);
		       0;
		   });

    $w->{window}->set_default_size($typical_width*2.7, 500);
    $w->{rwindow}->show_all;
    my $widgets = { w => $w, tree => $tree, tree_model => $tree_model, textcolumn => $textcolumn, pixcolumn => $pixcolumn,
		    info => $info, status => $status };

    ask_browse_tree_info_given_widgets($options, $widgets);
}


# -=-=-=---=-=-=---=-=-=-- install packages -=-=-=---=-=-=---=-=-=-

sub get_installable_pkgs {
    my ($updates, $opts) = @_;
    my $update_name = 'update_source';
    my %update_descr;
    my @update_medias;

    if ($updates) {
        my $urpm = urpm->new;
        $urpm->configure;
        $urpm->{fatal} = sub {
            interactive_msg(N("Fatal error"),
                            N("A fatal error occurred: %s.", $_[1]));
            myexit(-1);
        };
	my $statedir = $urpm->{statedir};
	@update_medias = grep { !$_->{ignore} && $_->{update} } @{$urpm->{media}};
	if (@update_medias > 0) {
	    if (!$opts->{skip_updating_mu}) {
		$options{'no-confirmation'} or interactive_msg_('rpmdrake',
N("I need to contact the mirror to get latest update packages.
Please check that your network is currently running.

Is it ok to continue?"), yesno => 1) or myexit(-1);
                $urpm->select_media(map { $_->{name} } @update_medias);
                update_sources($urpm, noclean => 1);
	    }
	} else {
            if (any { $_->{update} } @{$urpm->{media}}) {
                interactive_msg_(N("Already existing update medias"),
N("You already have at least one update media configured, but
all of them are currently disabled. You should run the Software
Medias Manager to enable at least one (check it in the Enabled?
column).

Then, restart MandrakeUpdate.", $update_name));
                myexit(-1);
                print "meuh\n";
            }
	  mu_retry_another_mirror:
	    my $m = choose_mirror();
	    $m or interactive_msg_(N("How to choose manually your mirror"),
N("You may also choose your desired mirror manually: to do so,
launch the Software Medias Manager, and then add a `Security
updates' media.

Then, restart MandrakeUpdate.", $update_name)), myexit(-1);
	    my ($r) = cat_('/etc/mandrake-release') =~ /release\s(\S+)/;
            add_medium_and_check($urpm, N("Please wait, adding medium..."), {},
                                 $update_name, "$m/$r/RPMS/", '../base/hdlist.cz', update => 1);
	    @update_medias = { name => $update_name };  #- hack to simulate a medium for parsing of descriptions
	}

	my ($cur, $section);
	foreach (map { cat_("$statedir/descriptions.$_->{name}"), '%package dummy' } @update_medias) {
	    /^%package (.+)/ and do {
		exists $cur->{importance} && !member($cur->{importance}, qw(security bugfix)) and $cur->{importance} = 'normal';
		$update_descr{$_} = $cur foreach @{$cur->{pkgs}};
		$cur = {};
		$cur->{pkgs} = [ split /\s/, $1 ];
		$section = 'pkg';
		next;
	    };
	    /^Update: (.+)/ && $section eq 'pkg' and $cur->{update} = $1;
	    /^Importance: (.+)/ && $section eq 'pkg' and $cur->{importance} = $1;
	    /^%pre/ and do { $section = 'pre'; next };
	    /^%description/ and do { $section = 'description'; next };
	    $section eq 'pre' and $cur->{pre} .= $_;
	    $section eq 'description' and $cur->{description} .= $_;
	}
    }
    my $wait = wait_msg_(N("Please wait, finding available packages..."));
    my $urpm = urpm->new;
    my %installable_pkgs;

    $urpm->configure;
    @update_medias = grep { !$_->{ignore} && $_->{update} } @{$urpm->{media}};

    $urpm->compute_installed_flags(db());

    foreach my $pkg (@{$urpm->{depslist}}) {
	$pkg->flag_upgrade or next;
	$updates and ($pkg->flag_installed && grep { $pkg->id >= $_->{start} && $pkg->id <= $_->{end} } @update_medias or next);
	$installable_pkgs{my_fullname($pkg)} = { selected => 0, pkg => $pkg };
    }

    remove_wait_msg($wait);
    ($urpm, \%installable_pkgs, \%update_descr);
}

sub dialog_rpmnew {
    my ($msg, %p2r) = @_;
    # /var/lib/nfs/etab /var/lib/nfs/rmtab /var/lib/nfs/xtab /var/cache/man/whatis
    my @ignores_rpmnew = qw(/etc/group /etc/passwd /etc/localtime /etc/shells /etc/adjtime /etc/ld.so.conf /etc/modules 
                        /etc/security/fileshare.conf /etc/sudoers /etc/sysconfig/alsa /etc/sysconfig/autofsck /etc/sysconfig/harddisks
                        /etc/sysconfig/installkernel /etc/sysconfig/msec /etc/sysconfig/nfs /etc/sysconfig/pcmcia /etc/sysconfig/init
                        /etc/sysconfig/rawdevices /etc/sysconfig/saslauthd /etc/sysconfig/syslog /etc/sysconfig/usb /etc/sysconfig/xinetd);
    @{$p2r{$_}} = grep { !member($_, @ignores_rpmnew) } @{$p2r{$_}} foreach keys %p2r;
    my $sum_rpmnew = sum(map { int @{$p2r{$_}} } keys %p2r);
    $sum_rpmnew == 0 and return 1;
    my @inspect_wsize = ($typical_width*2.5, 500);
    my $inspect = sub {
	my ($file) = @_;
	my $d = ugtk2->new(N("Inspecting %s", $file), grab => 1, transient => $w->{rwindow});
	my $save_wsize = sub { @inspect_wsize = $d->{rwindow}->get_size };
	my ($rpmnew, $rpmsave) = ("$file.rpmnew", "$file.rpmsave");
	my $rpmfile = 'rpmnew';
	-r $rpmnew or $rpmfile = 'rpmsave';
	-r $rpmnew && -r $rpmsave && (stat $rpmsave)[9] > (stat $rpmnew)[9] and $rpmfile = 'rpmsave';
	$rpmfile eq 'rpmsave' and $rpmnew = $rpmsave;
	my %texts;
	gtkadd($d->{window},
	       gtkpack_(Gtk2::VBox->new(0, 5),
			1, create_vpaned(
				  create_vpaned(gtkpack_(Gtk2::VBox->new(0, 0),
							 0, gtkset_markup(Gtk2::Label->new, "<span font_desc=\"monospace\">$file:</span>"),
							 1, create_scrolled_window($texts{file} = Gtk2::TextView->new)),
						gtkpack_(Gtk2::VBox->new(0, 0),
							 0, gtkset_markup(Gtk2::Label->new, "<span font_desc=\"monospace\">$rpmnew:</span>"),
							 1, create_scrolled_window($texts{rpmnew} = Gtk2::TextView->new)),
						resize1 => 1),
				  gtkpack_(Gtk2::VBox->new(0, 0),
					   0, Gtk2::Label->new(N("changes:")),
					   1, create_scrolled_window($texts{diff} = Gtk2::TextView->new)),
				  resize1 => 1),
			0, gtkpack__(create_hbox(),
				     gtksignal_connect(Gtk2::Button->new(N("Remove .%s", $rpmfile)),
						       clicked => sub { $save_wsize->(); unlink $rpmnew; Gtk2->main_quit }),
				     gtksignal_connect(Gtk2::Button->new(N("Use .%s as main file", $rpmfile)),
						       clicked => sub { $save_wsize->(); renamef($rpmnew, $file); Gtk2->main_quit }),
				     gtksignal_connect(Gtk2::Button->new(N("Do nothing")),
						       clicked => sub { $save_wsize->(); Gtk2->main_quit }),
				    )));
	my %contents = (file => scalar(cat_($file)), rpmnew => scalar(cat_($rpmnew)));
	gtktext_insert($texts{$_}, [ [ $contents{$_}, { 'font' => 'monospace' } ] ]) foreach keys %contents;
	my @regexps = ([ '^(--- )|(\+\+\+ )', 'blue' ], [ '^@@ ', 'darkcyan' ], [ '^-', 'red3' ], [ '^\+', 'green3' ]);
	my $line2col = sub { $_[0] =~ /$_->[0]/ and return $_->[1] foreach @regexps; 'black' };
	gtktext_insert($texts{diff}, [ map { [ $_, { 'font' => 'monospace', 'foreground' => $line2col->($_) } ] } `diff -u $file $rpmnew` ]);
	$d->{rwindow}->set_default_size(@inspect_wsize);
	$d->main;
    };

    interactive_packtable(N("Installation finished"),
			  $w->{rwindow},
			  $msg,
			  [ map { my $pkg = $_;
				  map {
				      my $f = $_;
				      my $b;
				      [ gtkpack__(Gtk2::HBox->new(0, 0),
						  gtkset_markup(gtkset_selectable(Gtk2::Label->new, 1),
								"$pkg:<span font_desc=\"monospace\">$f</span>")),
					gtksignal_connect($b = Gtk2::Button->new(N("Inspect...")), clicked => sub {
							      $inspect->($f);
							      -r "$f.rpmnew" || -r "$f.rpmsave" or $b->set_sensitive(0)
							  }) ]
				  } @{$p2r{$pkg}}
			      } keys %p2r ],
			  [ gtksignal_connect(Gtk2::Button->new(N("Ok")),
					      clicked => sub { Gtk2->main_quit }) ]);
    return 0;
}

sub perform_installation {  #- (partially) duplicated from /usr/sbin/urpmi :-(
    my ($urpm) = @_;

    my $fatal_msg;
    my @error_msgs;
    local $urpm->{fatal} = sub { $fatal_msg = $_[1]; printf STDERR "Fatal: %s\n", $_[1]; goto fatal_error };
    local $urpm->{error} = sub { push @error_msgs, $_[0]; printf STDERR "Error: %s\n", $_[0] };

    $w->{rwindow}->set_sensitive(0);

    standalone::explanations("Removing package $_") foreach keys %{$urpm->{state}{ask_remove}};
    
    my %pkgs = map { $_->id => undef } grep { $_->flag_selected } @{$urpm->{depslist}}; 
    my ($local_sources, $list, $local_to_removes) = $urpm->get_source_packages(\%pkgs);
    my $distant_number;
    foreach my $l (@$list) {
        foreach (sort values %$l) {
            standalone::explanations("Installing package $_");
            /^file|removable/ or $distant_number++;
        }
    }
    if (!$local_sources && (!$list || !@$list)) {
        interactive_msg_(N("Unable to get source packages."),
                         N("Unable to get source packages, sorry. %s",
                           @error_msgs ? N("\n\nError(s) reported:\n%s", join("\n", @error_msgs)) : ''));
        goto return_with_error;
    }
    foreach (@$local_to_removes) {
        unlink $_;
    }

    gurpm::init(N("Package installation..."), N("Initializing..."));
    my $distant_progress;
    my %sources = $urpm->download_source_packages($local_sources, $list, force_local => 1,
                                                  ask_for_medium => sub {
                                                      interactive_msg_(N("Change medium"),
                                                                       N("Please insert the medium named \"%s\" on device [%s]", @_),
                                                                       yesno => 1, text => { yes => N("Ok"), no => N("Cancel") }) },
                                                  callback => sub {
                                                      my ($mode, $file, $percent) = @_;
                                                      if ($mode eq 'start') {
                                                          gurpm::label(N("Downloading package `%s' (%s/%s)...",
                                                                         basename($file), ++$distant_progress, $distant_number));
                                                      } elsif ($mode eq 'progress') {
                                                          gurpm::progress($percent/100);
                                                      } elsif ($mode eq 'end') {
                                                          gurpm::progress(1);
                                                      }
                                                  });
    my %sources_install = %{$urpm->extract_packages_to_install(\%sources) || {}};
    my @rpms_install = grep { !/\.src\.rpm$/ } values %sources_install;
    my @rpms_upgrade = grep { !/\.src\.rpm$/ } values %sources;

    if (!$options{'no-verify-rpm'}) {
        gurpm::label(N("Verifying packages signatures..."));
        my $total = @rpms_install + @rpms_upgrade;
        my $progress;
        my @invalid_sources;
        foreach (@rpms_install, @rpms_upgrade) {
            URPM::verify_rpm($_) =~ /NOT OK/ and push @invalid_sources, $_;
            gurpm::progress(++$progress/$total);
        }
        if (@invalid_sources) {
            interactive_msg_('rpmdrake',
                             N("The following packages have bad signatures:\n\n%s\n\nDo you want to continue installation?",
                               join "\n", @invalid_sources), yesno => 1) or goto return_with_error;
        }
    }

    if (@rpms_install || @rpms_upgrade) {
        foreach (@rpms_install, @rpms_upgrade) {
            m|^/| && ! -e $_ or next;
            interactive_msg_(N("Installation failed"),
                             N("Installation failed, some files are missing.\nYou may want to update your medias database.") .
                             (@error_msgs ? N("\n\nError(s) reported:\n%s", join("\n", @error_msgs)) : ''));
            goto return_with_error;
        }
        my $progress_nb;
        my $total_nb = grep { m|^/| } @rpms_install, @rpms_upgrade;
        my $something_installed;
        my $callback_inst = sub {
            my ($urpm, $type, $id, $subtype, $amount, $total) = @_;
            my $pkg = defined $id && $urpm->{depslist}[$id];
            
            if ($subtype eq 'start') {
                if ($type eq 'trans') {
                    gurpm::label(N("Preparing packages installation..."));
                } else {
                    $something_installed = 1;
                    gurpm::label(N("Installing package `%s' (%s/%s)...", $pkg->name, ++$progress_nb, $total_nb));
                }
            } elsif ($subtype eq 'progress') {
                gurpm::progress($amount/$total);
            }
        };
        my @errors = $urpm->install([ keys %{$urpm->{state}{ask_remove} || {}} ], \%sources_install, \%sources, translate_message => 1,
                                    post_clean_cache => 1, callback_inst => $callback_inst, callback_trans => $callback_inst);
        gurpm::end();
        $urpm->try_umounting_removables;

        if (@errors || @error_msgs) {
            interactive_msg_(N("Problem during installation"),
                             N("There was a problem during the installation:\n\n%s",
                               join("\n", @errors, @error_msgs)));
            $w->{rwindow}->set_sensitive(1);
            return !$something_installed;
        }

        my %pkg2rpmnew;
        foreach my $u (@rpms_upgrade) {
            $u =~ m|/([^/]+-[^-]+-[^-]+)\.[^\./]+\.rpm$|
              and $pkg2rpmnew{$1} = [ grep { m|^/etc| && (-r "$_.rpmnew" || -r "$_.rpmsave") }
                                      map { chomp_($_) } `rpm -ql $1` ];
        }
        dialog_rpmnew(N("The installation is finished; %s.\n\nSome configuration files were created as `.rpmnew' or `.rpmsave',\nyou may now inspect some in order to take actions:", N("everything was installed correctly")),
                      %pkg2rpmnew)
          and interactive_msg_(N("Everything installed successfully"),
                               N("All requested packages were installed successfully."));
    } else {
        gurpm::end();
        $urpm->try_umounting_removables;
        interactive_msg_(N("No package found for installation."),
                         N("Unrecoverable error: no package found for installation, sorry."));
    }

    $w->{rwindow}->set_sensitive(1);
    return 0;

  fatal_error:
    gurpm::end();
    interactive_msg_(N("Installation failed"),
                     N("There was a problem during the installation:\n\n%s", $fatal_msg));
  return_with_error:
    gurpm::end();
    $w->{rwindow}->set_sensitive(1);
    return 1;
}


# -=-=-=---=-=-=---=-=-=-- remove packages -=-=-=---=-=-=---=-=-=-

sub get_installed_pkgs {
    use URPM;

    my $wait = wait_msg_(N("Please wait, reading packages database..."));
    my @base = qw(basesystem);
    my (%base, %basepackages);
    my $db = db();
    my $sig_handler = sub { undef $db; exit 3 };
    local $SIG{INT} = $sig_handler;
    local $SIG{QUIT} = $sig_handler;
    while (defined(local $_ = shift @base)) {
	exists $basepackages{$_} and next;
	$db->traverse_tag(m|^/| ? 'path' : 'whatprovides', [ $_ ], sub {
			      push @{$basepackages{$_}}, my_fullname($_[0]);
			      push @base, $_[0]->requires_nosense;
			  });
    }
    foreach (values %basepackages) {
	my $n = @$_;
	foreach (@$_) {
	    $base{$_} = \$n;
	}
    }
    my %installed_pkgs;
    $db->traverse(sub {
		      my ($pkg) = @_;
		      my $fullname = my_fullname($pkg);
		      if (!$base{$fullname} || ${$base{$fullname}} != 1) {
			  #- I need to extract summary and description since they'll be lost when $pkg->pack_header
			  $installed_pkgs{$fullname} = { selected => 0, pkg => $pkg, urpm_name => urpm_name($pkg), summary => $pkg->summary,
							 description => beautify_description($pkg->description) };
			  $base{$fullname} and $installed_pkgs{$fullname}{base} = \${$base{$fullname}};
		      }
		      $pkg->pack_header;
		  });
    remove_wait_msg($wait);
    (urpm->new, \%installed_pkgs);
}

sub perform_removal {
    my ($urpm, $pkgs) = @_;
    my @toremove = map { if_($pkgs->{$_}{selected}, $pkgs->{$_}{urpm_name}) } keys %$pkgs;
    standalone::explanations("Removing package $_") foreach sort @toremove;
    my @results;
    slow_func(N("Please wait, removing packages..."),
	      sub { @results = $urpm->install(\@toremove, {}, {}, translate_message => 1) });
    if (@results) {
	interactive_msg_(N("Problem during removal"),
			 N("There was a problem during the removal of packages:\n\n%s", join("\n",  @results)));
	return 1;
    } else {
	return 0;
    }
}


# -=-=-=---=-=-=---=-=-=-- main -=-=-=---=-=-=---=-=-=-

if ($options{'merge-all-rpmnew'}) {
    my %pkg2rpmnew;
    print "Searching .rpmnew and .rpmsave files...\n";
    db->traverse(sub {
		     my $n = my_fullname($_[0]);
		     $pkg2rpmnew{$n} = [ grep { m|^/etc| && (-r "$_.rpmnew" || -r "$_.rpmsave") } map { chomp_($_) } $_[0]->files ];
		 });
    print "done.\n";
    $typical_width = 280;
    dialog_rpmnew('', %pkg2rpmnew) and print "Nothing to do.\n";
    myexit(0);
}


readconf();

if (!$> && !member($MODE, @$already_splashed)) {
    interactive_msg('rpmdrake',
N("%s

Is it ok to continue?",
        $MODE eq 'remove' ?
  N("Welcome to the software removal tool!

This tool will help you choose which software you want to remove from
your computer.")
      : $MODE eq 'update' ?
  N("Welcome to MandrakeUpdate!

This tool will help you choose the updates you want to install on your
computer.")
      :
  N("Welcome to the software installation tool!

Your Mandrake Linux system comes with several thousands of software
packages on CDROM or DVD. This tool will help you choose which software
you want to install on your computer."))
  , yesno => 1) or myexit(-1);
	push @$already_splashed, $MODE;
    }

if ($MODE eq 'remove') {
    run_treeview_dialog(sub { get_installed_pkgs() }, \&perform_removal);
} elsif ($MODE eq 'update') {
    run_treeview_dialog(sub { get_installable_pkgs(1, @_) }, \&perform_installation);
} else {
    run_treeview_dialog(sub { get_installable_pkgs() }, \&perform_installation);
}

writeconf();

myexit(0);
